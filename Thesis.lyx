#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
% set author and title for the CL class --- why the fuck is that needed?
%\plainauthor{Michael Färber}
%\plaintitle{Complexity of equivalence proofs of simple deterministic grammars}

% to show DRAFT watermark
%\usepackage[firstpage]{draftwatermark}

\usepackage{bussproofs}

% make sum/integral limits always appear above/below the operator, not next to it
\everymath{\displaystyle}

% center figures in all float environments
% (collides with LyX if we use rotated figures, therefore disabled)
%\usepackage{floatrow}

% center figures in all float environments
\makeatletter
\g@addto@macro\@floatboxreset{\centering}
\makeatother

% importing SVG files with LaTeX code in it, as created by Inkscape
\newcommand{\includesvg}[1]{\input{#1.pdf_tex}}

% graph drawing
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows, positioning}

% algorithms
\usepackage{algorithm}
\usepackage{algpseudocode}
% to fix nested calls in algorithms --- if not, nested calls produce LaTeX errors
\usepackage{fixltx2e}
\MakeRobust{\Call}

% include gnuplot files via TikZ
\usepackage{gnuplot-lua-tikz}

% don't show "section §1.1" and "equation (3.2)" in references, but "section 1.1" and "equation 3.2"
\newref{sec}{name = {section~}, refcmd = {\ref{#1}}}
\newref{eq}{name = {equation~}, refcmd = {\ref{#1}}}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Complexity of equivalence proofs of simple deterministic grammars
\end_layout

\begin_layout Author
Michael Färber
\end_layout

\begin_layout Publishers
Supervisors: Géraud Sénizergues
\begin_inset Foot
status open

\begin_layout Plain Layout
Université Bordeaux 1
\end_layout

\end_inset

, Cezary Kaliszyk
\begin_inset Foot
status open

\begin_layout Plain Layout
Universität Innsbruck
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Equivalence of simple deterministic grammar is decidable in PTIME.
 We created a new equivalence proof system, for which we implemented an
 algorithm to decide equivalence of simple deterministic grammars and to
 issue a complementary equivalence proof, which we then verify automatically.
 We proved that our proof system is sound and complete, by showing that
 our algorithm runs in 2-EXPTIME (although in all our experiments it needed
 at most EXPTIME) and finds a proof of equivalence if and only if the equivalenc
e holds.
 Furthermore, we made a set of grammars containing equivalent variables,
 whose equivalences are non-trivial to prove.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "IncludesT.lyx"

\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
My thanks go to:
\end_layout

\begin_layout Itemize
My supervisor Géraud, first for your excellent logic lecture, then for your
 continuous support towards me and this thesis, but also for introducing
 me to the French academic world at Île de Ré.
\end_layout

\begin_layout Itemize
My supervisor Cezary, for supporting me and my studies since we met in 2012,
 and for giving me additional helpful advice for my thesis.
 Furthermore, for enduring the long-distance calls of dubious quality.
\end_layout

\begin_layout Itemize
Aart Middeldorp, Georg Moser, Pierre Castéran, Marc Zeitoun and Anca Muscholl
 for your amazing logic lectures, of which I had the joy to attend at least
 four different ones during the last two years.
\end_layout

\begin_layout Itemize
Walter for introducing me to the field of logic and therefore motivating
 the choice of my master studies.
 I wish you all the best for your so far highly promising acting career
 in German blockbusters!
\end_layout

\begin_layout Itemize
Noël and Romaric for our delightful lunchs at the restaurant universitaire,
 thereby easing my days otherwise plain of work --- vive le poulpe
\begin_inset space ~
\end_inset

!
\end_layout

\begin_layout Itemize
Simon for our common bicycle tours, museum and concert visits, and especially
 for your interest in my work --- I wish you the best on your way to become
 the Poincaré of the 21th century.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

Chœur Voyageur
\begin_inset Quotes erd
\end_inset

 for letting me sing with you for the greater good of the music, thereby
 providing me a great diversion from my studies, as well as for the awesome
 voyages as far away as Seville.
\end_layout

\begin_layout Itemize
All my other friends which I met during my year in France --- I can not
 enumerate all of you here, as the thesis would be about twice as big that
 way, but I assure you made my year rock!
\end_layout

\begin_layout Itemize
Of course my family, to which I owe my greatest thanks for supporting my
 studies up to this point, and for being there for me whenever I needed
 you, sometimes even going so far as to abandon the dinner table for an
 incoming call.
 :)
\end_layout

\begin_layout Itemize
Last but not least an extended member of my family, namely my cousin Mino,
 for your most gentle invitation to the south of France and for your most
 continuous interest in my thesis, which was unique among my extrauniversitary
 circles and motivated me greatly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
In computer science, there exist many algorithms that return a certain result,
 such as 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

, but do not certify their answer with an easily verifiable 
\emph on
proof
\emph default
.
 Nonetheless, users usually trust these algorithms, because their correctness
 is proven, but it is still possible that
\end_layout

\begin_layout Itemize
an implementation of an algorithm may be erroneous, or
\end_layout

\begin_layout Itemize
the machine executing the algorithm misbehaves, or
\end_layout

\begin_layout Itemize
the compiler translating the algorithm into machine code contains errors,
\end_layout

\begin_layout Standard
thus possibly producing a wrong result despite a flawless algorithm.
\end_layout

\begin_layout Standard
A possible remedy for this problem is to generate proofs for the results.
 This way, users can validate the proofs and detect possible errors in the
 execution of the algorithm.
\end_layout

\begin_layout Standard
In this document, we considered the problem of equivalence of simple determinist
ic grammars, which was shown to be decidable by Korenjak and Hopcroft in
 
\begin_inset CommandInset citation
LatexCommand cite
key "korenjak1966"

\end_inset

.
 Thirty years later, an efficient algorithm for the problem in PTIME was
 presented by Hirshfeld, Faron and Moller in 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset

, however, this algorithm does not yield proofs.
 Another ten years later, Lasota and Rytter 
\begin_inset CommandInset citation
LatexCommand cite
key "lasota2006"

\end_inset

 showed a new algorithm for the problem, which improves performance over
 the former algorithm, but still remains in PTIME.
\end_layout

\begin_layout Standard
We created a relatively simple proof system to prove equivalences of simple
 deterministic grammars, and attempted to find algorithms based on ideas
 of the existing algorithms to construct equivalence proofs automatically.
 Furthermore, we constructed a test suite of non-trivially equivalent grammars.
 Based on this test suite, we compared the performances of our algorithms:
 The best algorithm we found so far always terminated in EXPTIME, and we
 proved it to have a maximal complexity of 2-EXPTIME.
 Using the latter result, we proved that our proof system is complete, and
 we proved that it is also sound.
\end_layout

\begin_layout Standard
This document is structured as follows: In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Preliminaries"

\end_inset

, we explain basic concepts, such as languages, grammars and polynomials.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Existing-algorithms"

\end_inset

, we explain existing algorithms to determine equivalence of simple deterministi
c grammars.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Equivalence-proof-system"

\end_inset

, we explain our equivalence proof system.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Proof-construction-strategies"

\end_inset

, we discuss several possible options to construct equivalence proofs, showing
 our chosen path later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Proof-construction-algorithm"

\end_inset

.
 A short overview of our implementation
\begin_inset Foot
status open

\begin_layout Plain Layout
Available at 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/01mf02/thesis"

\end_inset

.
\end_layout

\end_inset

 and how it performs, is the subject of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementation-Experiments"

\end_inset

.
 We conclude our study in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusion"

\end_inset

.
 The appendix in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Appendix"

\end_inset

 contains the proof of soundness and completeness of our proof system.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
research witnesses in Hirshfeld paper ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
manual to Gérauds algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
isomorphism between trees/graphs/sets of rules ...
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Preliminaries
\begin_inset CommandInset label
LatexCommand label
name "chap:Preliminaries"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we define some terms we will use throughout the document.
 For a longer introduction, see the first chapters of 
\begin_inset CommandInset citation
LatexCommand cite
key "hopcroft1979,carton2008"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Symmetrical difference
\end_layout

\end_inset

 For two sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $A\Delta B:=\left(A-B\right)\cup\left(B-A\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Alphabet
\end_layout

\end_inset

An alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 is a finite set of symbols.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Word
\end_layout

\end_inset

A word 
\begin_inset Formula $w$
\end_inset

 over an alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 is a finite sequence 
\begin_inset Formula $w_{1}w_{2}\dots w_{n}$
\end_inset

, where each 
\begin_inset Formula $w_{i}$
\end_inset

 is a symbol in 
\begin_inset Formula $\Sigma$
\end_inset

 and the length of the word 
\begin_inset Formula $\left|w\right|$
\end_inset

 is 
\begin_inset Formula $n$
\end_inset

.
 The empty word 
\begin_inset Formula $\varepsilon$
\end_inset

 is defined to be the empty sequence, with 
\begin_inset Formula $\left|\varepsilon\right|=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Free monoid & semigroup
\end_layout

\end_inset

 The free monoid 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 of 
\begin_inset Formula $\Sigma$
\end_inset

 is the set of all words over 
\begin_inset Formula $\Sigma$
\end_inset

.
 The free semigroup of 
\begin_inset Formula $\Sigma$
\end_inset

 is 
\begin_inset Formula $\Sigma^{+}:=\Sigma^{*}\backslash\left\{ \varepsilon\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Language
\end_layout

\end_inset

 A language 
\begin_inset Formula $\mathcal{L}$
\end_inset

 over the alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 is a set of words over 
\begin_inset Formula $\Sigma$
\end_inset

, meaning 
\begin_inset Formula $\mathcal{L}\subset\mbox{\Sigma}^{*}$
\end_inset

.
 If two languages 
\begin_inset Formula $\mathcal{L}_{1}$
\end_inset

 and 
\begin_inset Formula $\mathcal{L}_{2}$
\end_inset

 are not equivalent, there exists a witness of non-equivalence 
\begin_inset Formula $w\in\Sigma^{*}$
\end_inset

 such that 
\begin_inset Formula $w\in\mathcal{L}(p_{1})\Delta\mathcal{L}(p_{2}).$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Concatenation of words
\end_layout

\end_inset

 The concatenation of two words 
\begin_inset Formula $u=u_{1}\dots u_{m}$
\end_inset

 and 
\begin_inset Formula $v=v_{1}\dots v_{n}$
\end_inset

 is the new word 
\begin_inset Formula $u\cdot v=u_{1}\dots u_{m}v_{1}\dots v_{n}$
\end_inset

.
 This operation is associative, i.e.
 
\begin_inset Formula $\left(u\cdot v\right)\cdot w=u\cdot\left(v\cdot w\right)$
\end_inset

, and the empty word 
\begin_inset Formula $\varepsilon$
\end_inset

 is its neutral element, i.e.
 
\begin_inset Formula $w\cdot\varepsilon=\varepsilon\cdot w=w$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Product of languages
\end_layout

\end_inset

 The product of two languages 
\begin_inset Formula $\mathcal{L}_{1},\,\mathcal{L}_{2}$
\end_inset

 is defined to be 
\begin_inset Formula 
\[
\mathcal{L}_{1}\cdot\mathcal{L}_{2}:=\bigcup_{\left\{ \left(x,y\right)\mid x\in\mathcal{L}_{1},\, y\in\mathcal{L}_{2}\right\} }x\cdot y.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Prefix & postfix
\end_layout

\end_inset

 If there exist languages 
\begin_inset Formula $\mathcal{L}_{1},\mathcal{L}_{2}$
\end_inset

 for a given language 
\begin_inset Formula $\mathcal{L}$
\end_inset

 such that 
\begin_inset Formula $\mathcal{L}=\mathcal{L}_{1}\cdot\mathcal{L}_{2}$
\end_inset

, then we call 
\begin_inset Formula $\mathcal{L}_{1}$
\end_inset

 prefix and 
\begin_inset Formula $\mathcal{L}_{2}$
\end_inset

 postfix of 
\begin_inset Formula $\mathcal{L}$
\end_inset

.
\end_layout

\begin_layout Section
Context-free grammars
\end_layout

\begin_layout Definition
A context-free grammar (CFG) is a triple 
\begin_inset Formula $(V,T,P)$
\end_inset

 such that
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $V$
\end_inset

 is a finite set of variables,
\end_layout

\begin_layout Itemize
\begin_inset Formula $T$
\end_inset

 is a finite set of terminals,
\end_layout

\begin_layout Itemize
\begin_inset Formula $P\subset V\times(V\cup T)^{*}$
\end_inset

 is a finite set of production rules.
 For each variable 
\begin_inset Formula $X\in V$
\end_inset

, there exists at least one production rule 
\begin_inset Formula $(X,\alpha)\in P$
\end_inset

, i.e.
\begin_inset Formula 
\[
\forall X\in V,\,\exists\alpha\in\left(V\cup T\right)^{*}:\,(X,\alpha)\in P.
\]

\end_inset

To express all production rules for a variable 
\begin_inset Formula $X\in V$
\end_inset

, we write
\begin_inset Formula 
\[
X\to\sum_{\left(X,\alpha\right)\in P}\alpha.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we define the different types of words.
\end_layout

\begin_layout Definition
A variable word denotes a finite sequence of variables 
\begin_inset Formula $w_{V}\in V^{*}$
\end_inset

, and a terminal word denotes a finite sequence of terminals 
\begin_inset Formula $w_{T}\in T^{*}$
\end_inset

.
\end_layout

\begin_layout Standard
We define the language 
\begin_inset Formula $\lang X$
\end_inset

 generated by a variable 
\begin_inset Formula $X$
\end_inset

 a bit later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Polynomials"

\end_inset

.
\end_layout

\begin_layout Standard
An important property of a variable is the length of its shortest producible
 word.
 We define a function to calculate this property.
\end_layout

\begin_layout Definition
The variable norm is a function 
\begin_inset Formula $\norm{\cdot}:V^{*}\to\left(\mathbb{N}\cup\left\{ \infty\right\} \right)$
\end_inset

.
 Given a variable word 
\begin_inset Formula $\alpha\in V^{*}$
\end_inset

, 
\begin_inset Formula $\norm{\alpha}$
\end_inset

 equals the length of the shortest terminal word 
\begin_inset Formula $w\in T^{*}$
\end_inset

 which can be produced from 
\begin_inset Formula $\alpha$
\end_inset

, i.e.
\begin_inset Formula 
\[
\norm{\alpha}:=\inf_{w\in\lang{\alpha}}\left|w\right|.
\]

\end_inset

In case that 
\begin_inset Formula $\alpha$
\end_inset

 contains a variable which produces no single finite word, 
\begin_inset Formula $\alpha$
\end_inset

 itself will also produce no single finite word, in which case 
\begin_inset Formula $\norm{\alpha}=\infty$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
A grammar is normed iff all its variables produce at least one finite word,
 i.e.
\begin_inset Formula 
\[
\forall X\in V:\,\norm X\neq\infty.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
A grammar 
\begin_inset Formula $G$
\end_inset

 is in 
\emph on
Greibach normal form
\emph default
 (GNF) iff each production rule has the form 
\begin_inset Formula $X\to a\alpha$
\end_inset

, where 
\begin_inset Formula $X\in V$
\end_inset

, 
\begin_inset Formula $a\in T$
\end_inset

 and 
\begin_inset Formula $\alpha\in V^{*}$
\end_inset

.
 If the length of the longest 
\begin_inset Formula $\alpha$
\end_inset

 is 
\begin_inset Formula $k$
\end_inset

, then 
\begin_inset Formula $G$
\end_inset

 is in 
\begin_inset Formula $k$
\end_inset

-GNF.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:Example-grammar"

\end_inset

Consider the following grammar:
\begin_inset Formula 
\begin{align*}
X & \to aX+bZ\\
Y & \to bZZ+aX\\
Z & \to c
\end{align*}

\end_inset

This is a simple deterministic grammar in 2-GNF, as there are maximally
 two variables on the right side of a production rule, namely in 
\begin_inset Formula $Y\to bZZ$
\end_inset

.
 To visualise the grammar, we may construct a production graph as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Production-graph"

\end_inset

:
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->, node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node (X)                 {$X$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Y)  [right of = X] {$Y$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Z)  [below of = X] {$Z$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (ZZ) [right of = Z] {$ZZ$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (e)  [below of = Z] {$
\backslash
varepsilon$};
\end_layout

\begin_layout Plain Layout

  
\backslash
path (X)  edge[loop above] node {$a$} (X)
\end_layout

\begin_layout Plain Layout

             edge             node {$b$} (Z)
\end_layout

\begin_layout Plain Layout

        (Y)  edge             node {$a$} (X)
\end_layout

\begin_layout Plain Layout

             edge             node {$b$} (ZZ)
\end_layout

\begin_layout Plain Layout

        (Z)  edge             node {$c$} (e)
\end_layout

\begin_layout Plain Layout

        (ZZ) edge             node {$c$} (Z);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Production-graph"

\end_inset

Production graph for example grammar.
\end_layout

\end_inset


\end_layout

\end_inset

 We interpret this graph as follows:
\end_layout

\begin_deeper
\begin_layout Itemize
Each edge represents a variable word.
\end_layout

\begin_layout Itemize
Each vertex with label 
\begin_inset Formula $a\in T$
\end_inset

 from 
\begin_inset Formula $w=X\beta$
\end_inset

 to 
\begin_inset Formula $w'$
\end_inset

 expresses that there exists a production rule 
\begin_inset Formula $\left(X,a\alpha\right)\in P$
\end_inset

 such that 
\begin_inset Formula $w'=\alpha\beta$
\end_inset

.
\end_layout

\begin_layout Itemize
Each path from a variable word 
\begin_inset Formula $w$
\end_inset

 to 
\begin_inset Formula $\varepsilon$
\end_inset

 represents a terminal word produced by 
\begin_inset Formula $w$
\end_inset

.
\end_layout

\begin_layout Itemize
The length of the shortest path from a terminal word 
\begin_inset Formula $w$
\end_inset

 to 
\begin_inset Formula $\varepsilon$
\end_inset

 is equivalent to 
\begin_inset Formula $\norm w$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Example
For example, 
\begin_inset Formula $\norm X=2$
\end_inset

, 
\begin_inset Formula $\norm Y=3$
\end_inset

 and 
\begin_inset Formula $\norm Z=1$
\end_inset

.
 Also, among others, 
\begin_inset Formula $bbc\in\lang Y$
\end_inset

 and 
\begin_inset Formula $aa^{*}bc\in\lang Y$
\end_inset

 hold.
\end_layout

\begin_layout Section
Simple deterministic grammars
\end_layout

\begin_layout Definition
A simple deterministic grammar (or simple context-free grammar), short SDG,
 is a context-free grammar in Greibach normal form, with the condition that
 for each variable 
\begin_inset Formula $X\in V$
\end_inset

 and each 
\begin_inset Formula $a\in T$
\end_inset

, there exists at most one rule 
\begin_inset Formula $X\to a\alpha$
\end_inset

 in 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Simple deterministic grammars are a subclass of context-free grammars; in
 fact, the relation between several language classes is 
\begin_inset Formula 
\[
\lang{\mathrm{SDG}}\subset\lang{\mathrm{DETCF}}\subset\lang{\mathrm{CF}},
\]

\end_inset

where 
\begin_inset Formula $\mathrm{DETCF}$
\end_inset

 denotes deterministic context-free grammars and 
\begin_inset Formula $\mathrm{CF}$
\end_inset

 denotes context-free grammars.
 
\begin_inset CommandInset citation
LatexCommand cite
key "harrison1978"

\end_inset


\end_layout

\begin_layout Standard
While each variable of a SDG can potentially produce a set of several different
 terminal words 
\begin_inset Formula $W_{T}\subset T^{+}$
\end_inset

, we also looked at the special case of SDGs where each variable 
\begin_inset Formula $X\in V$
\end_inset

 produces only one single terminal word 
\begin_inset Formula $w\in T^{+}$
\end_inset

:
\end_layout

\begin_layout Definition
A compression grammar is a simple deterministic grammar, with the condition
 that for each variable 
\begin_inset Formula $X\in V$
\end_inset

, there exists at most one word 
\begin_inset Formula $w\in\left(T\cup V\right)^{*}$
\end_inset

 such that 
\begin_inset Formula $X\to w$
\end_inset

 is in 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Note that while we can only produce one single terminal word with each variable
 of a compression grammar, the norm of each variable is still potentially
 exponential in the number of variables.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:2^n-grammar"

\end_inset

Consider the following grammar:
\begin_inset Formula 
\begin{align*}
F_{0} & \to a\\
F_{n+1} & \to aF_{n}F_{n}
\end{align*}

\end_inset

All variables of this grammar produce exactly one word.
 Furthermore, the greatest norm of all variables is exponential in the number
 of variables.
\end_layout

\begin_layout Corollary
For the grammar from example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:2^n-grammar"

\end_inset

 it holds that 
\begin_inset Formula $\norm{F_{n}}=2^{n+1}-1$
\end_inset

.
\end_layout

\begin_layout Proof
By induction on 
\begin_inset Formula $n$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n=0$
\end_inset

: 
\begin_inset Formula $\norm{F_{0}}=1=2^{1}-1$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $n+1$
\end_inset

: 
\begin_inset Formula $\norm{F_{n+1}}=1+2\cdot\norm{F_{n}}\overset{\text{ind.}}{=}1+2\cdot\left(2^{n+1}-1\right)=1+2^{n+2}-2=2^{n+2}-1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
Normalised SDGs
\end_layout

\begin_layout Standard
For the proof construction algorithms presented in this document, we use
 so-called 
\emph on
normalised
\emph default
 SDGs.
\end_layout

\begin_layout Standard
The only restriction of normalised SDGs with respect to SDGs is that normalised
 SDGs must be normed, because we extensively use the norm in our later algorithm
s.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The same restriction has also been imposed in 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996,lasota2006"

\end_inset

.
\end_layout

\end_inset

 This restriction does not limit the class of languages for which we can
 decide equivalence, as we only consider languages containing finite words:
 For simple deterministic grammars, we can find in linear time equivalent
 grammars exclusively containing variables which produce at least one finite
 word.
 
\begin_inset CommandInset citation
LatexCommand cite
key "yehudai1977"

\end_inset


\end_layout

\begin_layout Example
As a (perhaps surprising) consequence, in the grammar
\begin_inset Formula 
\begin{align*}
A & \to aA\\
B & \to bB
\end{align*}

\end_inset

the variables 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are equivalent, because 
\begin_inset Formula $\lang A=\lang B=\emptyset$
\end_inset

, as they both produce no single finite word.
\end_layout

\begin_layout Standard
Furthermore, we impose several ordering and naming conventions on any SDG
 grammar 
\begin_inset Formula $G=\left(V,T,P\right)$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V=\left\{ X_{1},\dots,X_{n}\right\} $
\end_inset

, where 
\begin_inset Formula $X_{1}$
\end_inset

 to 
\begin_inset Formula $X_{n}$
\end_inset

 are ordered by ascending norm, i.e.
\begin_inset Formula 
\begin{equation}
\forall i\forall j:\,1\leq i\leq j\leq n\implies\norm{X_{i}}\leq\norm{X_{j}}.\label{eq:Norms-ordered}
\end{equation}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $P=\left\{ X_{i}\to a_{i,j}\alpha_{i,j}\mid a_{i,j}\in T\land\alpha_{i,j}\in V^{*}\right\} $
\end_inset

, where the number of productions for 
\begin_inset Formula $X_{i}$
\end_inset

 is 
\begin_inset Formula $p_{i}$
\end_inset

, then
\begin_inset Formula 
\begin{equation}
\forall i\forall j:\,1<j\leq p_{i}\implies\norm{\alpha_{i,1}}\leq\norm{\alpha_{i,j}}.\label{eq:Productions-ordered}
\end{equation}

\end_inset


\end_layout

\begin_layout Itemize
There exists a function 
\begin_inset Formula $v:T\to V$
\end_inset

 which associates each terminal 
\begin_inset Formula $a\in T$
\end_inset

 to a variable 
\begin_inset Formula $X\in V$
\end_inset

 such that there exists exactly one production rule for 
\begin_inset Formula $X$
\end_inset

 in 
\begin_inset Formula $P$
\end_inset

 with 
\begin_inset Formula $X\to a$
\end_inset

, i.e.
\begin_inset Formula 
\[
\forall a\in T,\,\exists X\in V:\,\left[\exists!\alpha:\,\left(X,\alpha\right)\in P\right]\land\left(X,a\right)\in P.
\]

\end_inset


\end_layout

\begin_layout Standard
The following lemma is a trivial consequence of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Productions-ordered"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:Norm-first-production"

\end_inset


\begin_inset Formula $\norm{X_{i}}=1+\norm{\alpha_{i,1}}$
\end_inset

.
\end_layout

\begin_layout Standard
With the help of this lemma we show another lemma, which we use later to
 ease calculating norms.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:Indices-ordered"

\end_inset


\begin_inset Formula $\forall i\forall X_{j}\in\alpha_{i,1}:\, j<i$
\end_inset

.
\end_layout

\begin_layout Proof
Assume to the contrary 
\begin_inset Formula $\exists i\exists X_{j}\in\alpha_{i,1}:\, j\geq i$
\end_inset

.
 Then there exist 
\begin_inset Formula $i,j$
\end_inset

 with 
\begin_inset Formula $\norm{X_{i}}\geq1+\norm{X_{j}}$
\end_inset

 (by lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Norm-first-production"

\end_inset

) and 
\begin_inset Formula $j\geq i$
\end_inset

.
 We distinguish two cases:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $j=i$
\end_inset

: This implies 
\begin_inset Formula $\norm{X_{i}}\geq1+\norm{X_{i}}$
\end_inset

, so 
\begin_inset Formula $\norm{X_{i}}>\norm{X_{i}}$
\end_inset

, which is a contradiction.
\end_layout

\begin_layout Itemize
\begin_inset Formula $j>i$
\end_inset

: By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Norms-ordered"

\end_inset

, 
\begin_inset Formula $\norm{X_{j}}\geq\norm{X_{i}}$
\end_inset

, implying 
\begin_inset Formula $\norm{X_{i}}<1+\norm{X_{j}}$
\end_inset

, which is a contradiction as well.
\end_layout

\end_deeper
\begin_layout Standard
Now we show an easy method to calculate the norm of each variable inductively:
 
\begin_inset Formula 
\[
\norm{X_{i}}=1+\sum_{1\leq p\leq\left|\alpha_{i,1}\right|}\norm{\alpha_{i,1}\left[p\right]},
\]

\end_inset

where 
\begin_inset Formula $w\left[p\right]$
\end_inset

 denotes the 
\begin_inset Formula $p$
\end_inset

-th letter of the word 
\begin_inset Formula $w$
\end_inset

.
 This function just sums up the norms of all variables of the first production
 rule of a variable.
 It terminates as by lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Indices-ordered"

\end_inset

, all variables in the first production rule 
\begin_inset Formula $\alpha_{i,1}$
\end_inset

 of each variable 
\begin_inset Formula $X_{i}$
\end_inset

 have a smaller index than 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Now let us inspect an example normalisation of a grammar.
\end_layout

\begin_layout Example
We consider the grammar from example 
\begin_inset CommandInset ref
LatexCommand formatted
reference "ex:Example-grammar"

\end_inset

.
 First, we note that for the terminals 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

, there exist no dedicated variables, so we add
\begin_inset Formula 
\begin{align*}
A & \to a\\
B & \to b
\end{align*}

\end_inset

to the grammar.
 At this point, we write down all variables with their production rules
 ordered by ascending norm, i.e.
\begin_inset Formula 
\begin{align*}
A & \to a\\
B & \to b\\
Z & \to c\\
X & \to aX+bZ\\
Y & \to bZZ+aX
\end{align*}

\end_inset

Now we need to verify whether the first production rule of each variable
 has the smallest norm of all production rules for this variable.
 As 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 only have one production rule, the property obviously holds for these variables
, but what about 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

? Looking at the production rules of 
\begin_inset Formula $X$
\end_inset

, we note that 
\begin_inset Formula $\norm X=2$
\end_inset

 and 
\begin_inset Formula $\norm Z=1$
\end_inset

, so the property does not hold for 
\begin_inset Formula $X$
\end_inset

, which we fix by changing the order of the production rules of 
\begin_inset Formula $X$
\end_inset

.
 For 
\begin_inset Formula $Y$
\end_inset

, though, the property holds, as 
\begin_inset Formula $\norm{ZZ}=\norm X=2$
\end_inset

.
 The intermediate result after this transformation step, where we only changed
 the order of production rules of 
\begin_inset Formula $X$
\end_inset

, is:
\begin_inset Formula 
\begin{align*}
A & \to a\\
B & \to b\\
Z & \to c\\
X & \to bZ+aX\\
Y & \to bZZ+aX
\end{align*}

\end_inset

After renaming the variables, the final grammar is:
\begin_inset Formula 
\begin{align*}
X_{1} & \to a\\
X_{2} & \to b\\
X_{3} & \to c\\
X_{4} & \to bX_{3}+aX_{4}\\
X_{5} & \to bX_{3}X_{3}+aX_{4}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We can show that the norms of grammar variables 
\begin_inset Formula $X_{i}$
\end_inset

 are exponentially bounded by their index 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:Norm-bounded"

\end_inset

Given a normalised SDG 
\begin_inset Formula $G=\left(V,T,P\right)$
\end_inset

 in 
\begin_inset Formula $k$
\end_inset

-GNF, the upper bound of the norm of each variable 
\begin_inset Formula $X_{i}$
\end_inset

 is 
\begin_inset Formula $\sum_{x=0}^{i}k^{x}$
\end_inset

.
\end_layout

\begin_layout Proof
We prove this by induction on 
\begin_inset Formula $i$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $i=1$
\end_inset

: By definition, for all production rules 
\begin_inset Formula $X_{1}\to a_{1j}\alpha_{1j}$
\end_inset

 it holds that 
\begin_inset Formula $\alpha_{1j}=\emptyset$
\end_inset

, therefore 
\begin_inset Formula $\norm{X_{1}}=1\leq\sum_{x=0}^{1}k^{x}=1+k$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $i+1$
\end_inset

: The production rules of 
\begin_inset Formula $X_{i+1}$
\end_inset

 may contain only variables of degree 
\begin_inset Formula $i$
\end_inset

 or smaller.
 The greatest norm of 
\begin_inset Formula $X_{i+1}$
\end_inset

 can therefore be achieved by a production rule with a maximum number of
 appearances of 
\begin_inset Formula $X_{i}$
\end_inset

, so 
\begin_inset Formula $X_{i+1}\to a\left(X_{i}\right)^{k}$
\end_inset

.
 With our induction hypothesis 
\begin_inset Formula $\norm{X_{i}}\leq\sum_{x=0}^{i}k^{x}$
\end_inset

, we calculate the norm of 
\begin_inset Formula $X_{i+1}$
\end_inset

 to be 
\begin_inset Formula $\norm{X_{i+1}}=1+k\cdot\norm{X_{i}}=1+k\cdot\sum_{x=0}^{i}k^{x}=1+\sum_{x=0}^{i}k^{x+1}=\sum_{x=0}^{i+1}k^{x}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Because we need the bound of the norm later in the bound of proof size,
 we establish a bound that is slightly simpler to write.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:Poly-bound"

\end_inset

For 
\begin_inset Formula $k\geq0$
\end_inset

, 
\begin_inset Formula $\sum_{x=0}^{i}k^{x}\leq\left(k+1\right)^{i}$
\end_inset

.
\end_layout

\begin_layout Proof
By induction on 
\begin_inset Formula $i$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $i=0$
\end_inset

: 
\begin_inset Formula $k^{0}=1\leq1=\left(k+1\right)^{0}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $i+1$
\end_inset

: 
\begin_inset Formula $\sum_{x=0}^{i+1}k^{x}=\sum_{x=0}^{i}k^{x}+k^{i+1}\overset{\text{ind.}}{\leq}\left(k+1\right)^{i}+k^{i+1}\leq\left(k+1\right)^{i}+k\cdot\left(k+1\right)^{i}=\left(k+1\right)^{i}\cdot\left(k+1\right)=\left(k+1\right)^{n+1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Corollary
Given a normalised SDG 
\begin_inset Formula $G=\left(V,T,P\right)$
\end_inset

 in 
\begin_inset Formula $k$
\end_inset

-GNF, the upper bound of the norm of each variable 
\begin_inset Formula $X_{i}$
\end_inset

 is 
\begin_inset Formula $\left(k+1\right)^{i}$
\end_inset

.
\end_layout

\begin_layout Proof
By lemmas 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Norm-bounded"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Poly-bound"

\end_inset

, we have that 
\begin_inset Formula $\norm{X_{i}}\leq\sum_{x=0}^{i}k^{x}$
\end_inset

 and 
\begin_inset Formula $\sum_{x=0}^{i}k^{x}\leq\left(k+1\right)^{i}$
\end_inset

, so the result follows by transitivity.
\end_layout

\begin_layout Section
Polynomials
\begin_inset CommandInset label
LatexCommand label
name "sec:Polynomials"

\end_inset


\end_layout

\begin_layout Standard
In our proof system in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Equivalence-proof-system"

\end_inset

, we use polynomials to represent proof judgements.
 Because the term 
\begin_inset Quotes eld
\end_inset

polynomial
\begin_inset Quotes erd
\end_inset

 is polysemous, we need to define our notion of polynomials and their relation
 to languages.
\end_layout

\begin_layout Standard
Let us start by defining some algebraic structures, which serve us later
 in the definitions of polynomials.
 For a more detailed source, see 
\begin_inset CommandInset citation
LatexCommand cite
key "berstel1984"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Monoid
\end_layout

\end_inset

A monoid is a pair 
\begin_inset Formula $\left(A,\cdot\right)$
\end_inset

 such that 
\begin_inset Formula $A$
\end_inset

 is a set and 
\begin_inset Formula $\cdot$
\end_inset

 is an associative operation such that
\end_layout

\begin_deeper
\begin_layout Itemize
For all 
\begin_inset Formula $a,b\in A$
\end_inset

, 
\begin_inset Formula $a\cdot b\in A$
\end_inset

.
\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $a,b,c\in A$
\end_inset

, 
\begin_inset Formula $a\cdot\left(b\cdot c\right)=\left(a\cdot b\right)\cdot c$
\end_inset

.
\end_layout

\begin_layout Itemize
There exists a neutral element 
\begin_inset Formula $n\in A$
\end_inset

 such that for all 
\begin_inset Formula $a\in A$
\end_inset

, 
\begin_inset Formula $a\cdot n=n\cdot a=a$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Definition
If it holds additionally for all 
\begin_inset Formula $a,b\in A$
\end_inset

 that 
\begin_inset Formula $a\cdot b=b\cdot a$
\end_inset

, then we call the monoid 
\emph on
commutative
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semiring
\end_layout

\end_inset

A semiring is a 3-tuple 
\begin_inset Formula $\left(A,\cdot,+\right)$
\end_inset

 such that
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(A,+\right)$
\end_inset

 is a commutative monoid, whose neutral element is noted 0.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(A,\cdot\right)$
\end_inset

 is a monoid, whose neutral element is noted 1.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\cdot$
\end_inset

 distributes over 
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Itemize
For each 
\begin_inset Formula $a\in A$
\end_inset

 we have 
\begin_inset Formula $a\cdot0=0\cdot a=0$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Definition
If it holds additionally for all 
\begin_inset Formula $a,b\in A$
\end_inset

 that 
\begin_inset Formula $a\cdot b=b\cdot a$
\end_inset

, then we call the semiring commutative.
\end_layout

\begin_layout Standard
In particular, the boolean semiring 
\begin_inset Formula $\mathbb{B}=\left(\left\{ 0,1\right\} ,\cdot,+\right)$
\end_inset

 is defined by 
\begin_inset Formula $1+1=1$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Formal power series
\end_layout

\end_inset

A formal power series 
\begin_inset Formula $S$
\end_inset

 is a total function from 
\begin_inset Formula $X^{*}$
\end_inset

 to 
\begin_inset Formula $K$
\end_inset

.
 The image of a word 
\begin_inset Formula $w\in X^{*}$
\end_inset

 with respect to 
\begin_inset Formula $S$
\end_inset

 is noted as 
\begin_inset Formula $\left(S,w\right)$
\end_inset

 and is called 
\emph on
coefficient
\emph default
 of 
\begin_inset Formula $w$
\end_inset

.
 The 
\emph on
support
\emph default
 of 
\begin_inset Formula $S$
\end_inset

 is defined as
\begin_inset Formula 
\[
\supp\left(S\right):=\left\{ w\in X^{*}\mid\left(S,w\right)\neq0\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semiring of formal power series
\end_layout

\end_inset

The set of formal power series over 
\begin_inset Formula $X$
\end_inset

 with coefficients in 
\begin_inset Formula $K$
\end_inset

 is noted 
\begin_inset Formula $K\left\langle \left\langle X\right\rangle \right\rangle $
\end_inset

.
 We enclose
\begin_inset Note Note
status open

\begin_layout Plain Layout
the right word?
\end_layout

\end_inset

 
\begin_inset Formula $K\left\langle \left\langle X\right\rangle \right\rangle $
\end_inset

 with a semiring structure as follows: If 
\begin_inset Formula $S,T$
\end_inset

 are two series, their sum is defined as
\begin_inset Formula 
\[
\left(S+T,w\right):=\left(S,w\right)+\left(T,w\right),
\]

\end_inset

and their product is defined as
\begin_inset Formula 
\[
\left(ST,w\right):=\sum_{uv=w}\left(S,u\right)\left(T,v\right),
\]

\end_inset

where the sum is finite.
\end_layout

\begin_layout Definition
Based on this, we also define
\begin_inset Formula 
\[
K\left\langle X\right\rangle :=\left\{ S\in K\left\langle \left\langle X\right\rangle \right\rangle \mid\left|\supp\left(S\right)\right|<\infty\right\} 
\]

\end_inset

to be the set of elements in 
\begin_inset Formula $K\left\langle X\right\rangle $
\end_inset

 with finite support.
\end_layout

\begin_layout Standard
We now define polynomials over 
\begin_inset Formula $\Sigma=V\cup T$
\end_inset

 to be the elements of the noncommutative semiring
\begin_inset Formula 
\[
R=\mathbb{B}\left\langle \Sigma\right\rangle .
\]

\end_inset

For each variable of a grammar, we define its grammar polynomial, which
 is the polynomial representation of all production rules belonging to the
 variable.
\end_layout

\begin_layout Definition
For a grammar 
\begin_inset Formula $G=\left(V,T,P\right)$
\end_inset

, the grammar polynomial of a variable 
\begin_inset Formula $X\in V$
\end_inset

 is 
\begin_inset Formula 
\[
\Gr X=\sum_{\left(X,\alpha\right)\in P}\alpha.
\]

\end_inset


\end_layout

\begin_layout Standard
We define the language generated by a polynomial.
\end_layout

\begin_layout Definition
The language generated by a polynomial 
\begin_inset Formula $p$
\end_inset

 is defined as 
\begin_inset Formula 
\[
\lang p:=\left\{ w\in T^{*}\mid p\overset{*}{\to}w\right\} ,
\]

\end_inset

where 
\begin_inset Formula $\overset{*}{\to}$
\end_inset

 is the reflexive and transitive closure of the derivation relation, which
 is defined as in 
\begin_inset CommandInset citation
LatexCommand cite
key "carton2008"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is the derivation relation?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It follows as lemma:
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:Language-of-polynomial"

\end_inset


\begin_inset Formula 
\[
\lang p=\begin{cases}
\left\{ p\right\}  & p\in T\\
\lang{\Gr p} & p\in V\\
\lang{p_{1}}\cup\lang{p_{2}} & p=p_{1}+p_{2}\\
\lang x\cdot\lang y & p=p_{1}\cdot p_{2}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
To later measure the size of a proof, we define the size of a polynomial.
\end_layout

\begin_layout Definition
The size of a polynomial is the sum of terminals and variables appearing
 in the polynomial, i.e.
\begin_inset Formula 
\[
\size p=\begin{cases}
1 & p\in T\cup V\\
\size{p_{1}}+\size{p_{2}} & p=p_{1}+p_{2}\lor p=p_{1}\cdot p_{2}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Section
Simple polynomials
\end_layout

\begin_layout Standard
To reduce the number of proof construction rules and to simplify checking
 if two polynomials are equivalent, we define the class of 
\emph on
simple polynomials
\emph default
 
\begin_inset Formula $\mathcal{P}$
\end_inset

 over variables 
\begin_inset Formula $V$
\end_inset

 and terminals 
\begin_inset Formula $T$
\end_inset

.
 In a nutshell, a simple polynomial should be:
\end_layout

\begin_layout Itemize
a product of variables, or
\end_layout

\begin_layout Itemize
a sum of terms, where each term is either:
\end_layout

\begin_deeper
\begin_layout Itemize
a terminal, or
\end_layout

\begin_layout Itemize
the concatenation of a terminal with a product of variables.
\end_layout

\end_deeper
\begin_layout Standard
Additionally, we impose that all terminals of a sum have to be pairwise
 different.
 This restriction ensures compatibility of simple polynomials with simple
 deterministic grammars.
\end_layout

\begin_layout Definition
A simple polynomial 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 over variables 
\begin_inset Formula $V$
\end_inset

 and terminals 
\begin_inset Formula $T$
\end_inset

 is a polynomial (as defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Polynomials"

\end_inset

) with the following restrictions:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{align*}
\left(\exists w\in\supp\left(p\right):\, w\in V^{*}\right)\to & \:\forall w,w'\in\supp\left(p\right):\, w=w'\\
\lnot\left(\exists w\in\supp\left(p\right):\, w\in V^{*}\right)\to & \:\left(\forall w\in\supp\left(p\right):\, w\in TV^{*}\right)\land\\
 & \:\left(\forall w,w'\in\supp\left(p\right):\, w=au\land w'=av\to u=v\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Valid simple polynomials over the variables 
\begin_inset Formula $V=\left\{ X_{1},\dots,X_{4}\right\} $
\end_inset

 and terminals 
\begin_inset Formula $T=\left\{ a,b,c,d\right\} $
\end_inset

 include for example:
\end_layout

\begin_layout Itemize
\begin_inset Formula $b$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $X_{3}X_{2}$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $a+bX_{2}$
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Not
\emph default
 valid simple polynomials, over the same 
\begin_inset Formula $V$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

 include:
\end_layout

\begin_layout Itemize
\begin_inset Formula $X_{1}+X_{2}$
\end_inset

, because the addends start with a variable;
\end_layout

\begin_layout Itemize
\begin_inset Formula $a+X_{4}$
\end_inset

, because the second addend starts with a variable;
\end_layout

\begin_layout Itemize
\begin_inset Formula $abX_{2}+cX_{3}$
\end_inset

, because the first addend starts with multiple terminals instead of only
 one;
\end_layout

\begin_layout Itemize
\begin_inset Formula $aX_{1}+aX_{2}$
\end_inset

, because the terminal 
\begin_inset Formula $a$
\end_inset

 appears several times in the same sum.
\end_layout

\begin_layout Standard
Note that the last examples express valid non-simple polynomials.
\end_layout

\begin_layout Chapter
Existing algorithms
\begin_inset CommandInset label
LatexCommand label
name "chap:Existing-algorithms"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we discuss the history of the equivalence problem for simple
 deterministic grammars, and present some of the approaches in detail.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
The equivalence problem for SDGs is relatively old.
 We show its historical development:
\end_layout

\begin_layout Itemize
In 1966, a milestone towards its resolution has been achieved by Hopcroft
 and Korenjak when they showed that equivalence is decidable.
 
\begin_inset CommandInset citation
LatexCommand cite
key "korenjak1966"

\end_inset

 Since then, there have been continuous attempts to decide equivalence more
 efficiently.
\end_layout

\begin_layout Itemize
In 1978, Harrison showed a proof-like way to decide equivalence, which we
 discuss in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Harrison-equivalence-trees"

\end_inset

.
\end_layout

\begin_layout Itemize
In 1993, Caucal found the up to that date fastest decision procedure, which
 was however still exponential in size of the grammar.
 
\begin_inset CommandInset citation
LatexCommand cite
key "caucal1993"

\end_inset


\end_layout

\begin_layout Itemize
In 1994, Plandowski described a method to decide the equivalence of compression
 grammars in polynomial time.
 
\begin_inset CommandInset citation
LatexCommand cite
key "plandowski1994"

\end_inset

 Furthermore, that year Huynh and Tian showed an algorithm which could decide
 equivalence of SDGs and was in 
\begin_inset Formula $\Sigma_{2}^{P}$
\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand cite
key "huynh1994"

\end_inset


\end_layout

\begin_layout Itemize
In 1996, another major breakthrough was achieved by Hirshfeld, Faron and
 Moller, who were able to find an algorithm to decide equivalence of SDG
 in polynomial time.
 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset

 We discuss this algorithm in detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Hirshfeld-algorithm"

\end_inset

.
\end_layout

\begin_layout Itemize
In 2006, Lasota and Rytter presented another algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "lasota2006"

\end_inset

 of polynomial-time complexity to resolve the equivalence problem of simple
 deterministic grammars, improving the complexity of the Hirshfeld algorithm
 to 
\begin_inset Formula $\mathcal{O}\left(n^{6}\polylog n\right)$
\end_inset

.
 However, as the algorithm makes use of the same general principles as the
 Hirshfeld algorithm, we studied it only briefly.
\end_layout

\begin_layout Section
Harrison equivalence trees
\begin_inset CommandInset label
LatexCommand label
name "sec:Harrison-equivalence-trees"

\end_inset


\end_layout

\begin_layout Standard
In chapter 11.10 of 
\begin_inset CommandInset citation
LatexCommand cite
key "harrison1978"

\end_inset

, Harrison discusses the equivalence problem for simple languages.
 He presents so-called 
\emph on
equivalence trees
\emph default
, which resemble the proof trees of our proof system presented later in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Equivalence-proof-system"

\end_inset

.
 These equivalence trees are constructed through a series of transformations,
 which are applied on the proof tree nondeterministically.
 Harrison shows that each equivalence tree has at most a number of nodes
 exponential in the length of the longest word, which is equivalent to double-ex
ponential in the size of the grammar.
 He proves that the equivalence problem for simple grammars is decidable
 by the construction of an equivalence tree.
\end_layout

\begin_layout Section
Hirshfeld algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:Hirshfeld-algorithm"

\end_inset


\end_layout

\begin_layout Standard
The first polynomial-time algorithm to decide equivalence of SDGs was given
 by Hirshfeld, Faron and Moller in 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset

.
 One of the central techniques they use in their algorithm is the norm reduction
 function, which we shall define first and explain afterwards:
\end_layout

\begin_layout Definition
Norm reduction is a partial function from 
\begin_inset Formula $V^{*}\times\mathbb{N}$
\end_inset

 to 
\begin_inset Formula $V^{*}$
\end_inset

, which is undefined if the supplied natural number is greater than the
 norm of the supplied variable word.
\begin_inset Formula 
\begin{align*}
\left[\alpha\right]_{0} & =\alpha;\\
\left[X_{i}\alpha\right]_{p} & =\begin{cases}
\left[\alpha\right]_{p-\norm{X_{i}}} & p\geq\norm{X_{i}};\\
\left[\alpha_{i1}\right]_{p-1}\alpha & p<\norm{X_{i}}.
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Given a variable word 
\begin_inset Formula $u\in V^{*}$
\end_inset

, we can calculate 
\begin_inset Formula $\left[u\right]_{t}$
\end_inset

.
 If 
\begin_inset Formula $\left[u\right]_{t}$
\end_inset

 is defined (which is the case when
\begin_inset Formula $\norm u>t$
\end_inset

), then 
\begin_inset Formula $\norm{\left[u\right]_{t}}=\norm u-t$
\end_inset

 and 
\begin_inset Formula $\lang{\left[u\right]_{t}}=L_{1}$
\end_inset

, where 
\begin_inset Formula $\lang u=L_{1}\cdot L_{2}$
\end_inset

 for some 
\begin_inset Formula $L_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Informally, the norm reduction function attempts to determine a postfix
 of a given variable word, by 
\begin_inset Quotes eld
\end_inset

cutting away
\begin_inset Quotes erd
\end_inset

 the first 
\begin_inset Formula $p$
\end_inset

 characters of its shortest producible terminal word and returning the remaining
 variables.
 For example, if we know that 
\begin_inset Formula $AB\equiv CD$
\end_inset

 and 
\begin_inset Formula $\norm A>\norm C$
\end_inset

, then we conclude that 
\begin_inset Formula $C$
\end_inset

 is a prefix of 
\begin_inset Formula $A$
\end_inset

 and there has to exist a postfix 
\begin_inset Formula $\alpha=\left[A\right]_{\norm C}$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $A\equiv C\alpha$
\end_inset

 --- see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Motivation-Base"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
svgwidth{200pt}
\end_layout

\begin_layout Plain Layout


\backslash
includesvg{ABCD-base}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Motivation-Base"

\end_inset

Motivation of Caucal base.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
That idea is utilised at the core of the Hirshfeld algorithm, namely in
 the 
\emph on
Caucal base
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "caucal1990"

\end_inset

: It is a set storing the information which variables are prefixes of other
 variables.
 At first, the algorithm assumes every variable to be a prefix of each variable
 with greater index, creating an overestimation of the base as follows:
 
\begin_inset Formula 
\[
\left\{ \left(X_{j},X_{i}\left[X_{j}\right]_{\norm{X_{i}}}\right)\mid1\leq i<j\leq n\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Then, in an iterative process, the algorithm removes inequivalent pairs
 from the base, until the process stabilizes.
 To decide whether a base pair is equivalent, the algorithm relies --- amongst
 others --- on following theorem:
\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Fine and Wilf
\end_layout

\end_inset

If a word 
\begin_inset Formula $w$
\end_inset

 has periods 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 with 
\begin_inset Formula $p\geq q$
\end_inset

 and 
\begin_inset Formula $\length w+\gcd\left(p,q\right)\geq p+q$
\end_inset

, then 
\begin_inset Formula $\gcd\left(p,q\right)$
\end_inset

 is a period of 
\begin_inset Formula $w$
\end_inset

.
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset citation
LatexCommand cite
key "lothaire2002"

\end_inset

.
\end_layout

\begin_layout Standard
To illustrate the theorem of Fine and Wilf, consider the following word:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha=\lefteqn{\underbrace{abab}_{p_{2}=4}\underbrace{abab}\underbrace{abab}}\overbrace{\phantom{ababab}}^{p_{1}=6}\overbrace{\phantom{ababab}}
\]

\end_inset

We notice that 
\begin_inset Formula $\alpha$
\end_inset

 has two different periods --- 
\begin_inset Formula $p_{1}=6$
\end_inset

 and 
\begin_inset Formula $p_{2}=4$
\end_inset

 ---, from which we can deduce that 
\begin_inset Formula $\gcd\left(6,4\right)=2$
\end_inset

 is a third period, as 
\begin_inset Formula $\length{\alpha}+\gcd\left(p_{1},p_{2}\right)=12+2=14\geq10=6+4=p_{1}+p_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
An alignment of a word 
\begin_inset Formula $\alpha$
\end_inset

 against a word 
\begin_inset Formula $\beta$
\end_inset

 is an occurrence of 
\begin_inset Formula $\alpha$
\end_inset

 as subsequence of 
\begin_inset Formula $\beta$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset Argument
status open

\begin_layout Plain Layout
Lemma 3.5 from 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:Periodicity"

\end_inset

Let 
\begin_inset Formula $\alpha,\delta\in V^{*}$
\end_inset

 be words, and 
\begin_inset Formula $I$
\end_inset

 be the set of all indices 
\begin_inset Formula $i$
\end_inset

 such that there exists an alignment of 
\begin_inset Formula $\alpha$
\end_inset

 against 
\begin_inset Formula $\delta$
\end_inset

 in which the 
\begin_inset Formula $i$
\end_inset

-th symbol in 
\begin_inset Formula $\alpha$
\end_inset

 is matched to a distinguished symbol in 
\begin_inset Formula $\delta$
\end_inset

.
 Then the elements of 
\begin_inset Formula $I$
\end_inset

 form an arithmetic progression.
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset

.
\end_layout

\begin_layout Standard
To visualise the statement above, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Arithmetic-progression"

\end_inset

: There you see two words, 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\delta$
\end_inset

.
 Let us assume that the parts of 
\begin_inset Formula $\delta$
\end_inset

 below any 
\begin_inset Formula $\alpha$
\end_inset

 are equal to 
\begin_inset Formula $\alpha$
\end_inset

.
 Because all drawn instances of 
\begin_inset Formula $\alpha$
\end_inset

 overlap at the distinguished symbol 
\begin_inset Formula $s$
\end_inset

 of 
\begin_inset Formula $\delta$
\end_inset

, it follows that between the second and the third drawn instance of 
\begin_inset Formula $\alpha$
\end_inset

, there exist more alignments of 
\begin_inset Formula $\alpha$
\end_inset

 against 
\begin_inset Formula $\delta$
\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
svgwidth{300pt}
\end_layout

\begin_layout Plain Layout


\backslash
includesvg{FineWilf}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Arithmetic-progression"

\end_inset

Arithmetic progression.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This means that if there are more than three overlapping alignments of one
 variable against another, the algorithm only has to keep track of three
 of them, as one can deduce the other alignments, forming an arithmetic
 progression.
 This is substantial for the algorithm.
\end_layout

\begin_layout Chapter
Equivalence proof system
\begin_inset CommandInset label
LatexCommand label
name "chap:Equivalence-proof-system"

\end_inset


\end_layout

\begin_layout Standard
In this section, we introduce our system to prove equivalence of simple-determin
istic grammars.
 The motivation for creating this system was to find a very simple logic
 and to find out if we could prove all equivalences in it, and if so, which
 size these proofs would occupy.
 Therefore we made a system loosely resembling equational logic, however
 enhanced with implicit induction and rules specific to grammars.
 It is based on the proof system 
\begin_inset Formula $\mathcal{D}_{5}$
\end_inset

 in 
\begin_inset CommandInset citation
LatexCommand cite
key "senizergues2001"

\end_inset

, which can be used to prove equivalence of deterministic context-free grammars.
\end_layout

\begin_layout Section
Examples
\end_layout

\begin_layout Standard
To give an intuition of our proof system, we first present some simple example
 proofs before defining the system rigorously.
\end_layout

\begin_layout Example
Consider the following grammar:
\begin_inset Formula 
\begin{align*}
X & \to a+bC_{1}\\
Y & \to a+bC_{2}\\
C_{1} & \to c\\
C_{2} & \to c
\end{align*}

\end_inset

We see at a glance that 
\begin_inset Formula $C_{1}\equiv C_{2}$
\end_inset

 and therefore 
\begin_inset Formula $X\equiv Y$
\end_inset

 holds.
 Let us begin with a proof of 
\begin_inset Formula $C_{1}\equiv C_{2}$
\end_inset

:
\begin_inset Formula 
\[
\bussproof{\transinf{C_{1}}{C_{2}}{\gr{C_{1}}c}{\syminf c{C_{2}}{\gr{C_{2}}c}}}
\]

\end_inset

In this proof, we used the transitivity and symmetry properties of the equivalen
ce relation, as well as the grammar rule, which states that a variable is
 equivalent to its production rules.
\end_layout

\begin_layout Example
Now we prove 
\begin_inset Formula $X\equiv Y$
\end_inset

:
\begin_inset Formula 
\[
\bussproof{\transinf XY{\gr X{a+bC_{1}}}{\syminf{a+bC_{1}}Y{\transinf Y{a+bC_{1}}{\gr Y{a+bC_{2}}}{\plusinf{a+bC_{2}}{a+bC_{1}}{\refl aa}{\timesinf{bC_{2}}{bC_{1}}{\refl bb}{\transinf{C_{2}}{C_{1}}{\gr{C_{2}}c}{\syminf c{C_{1}}{\gr{C_{1}}c}}}}}}}}
\]

\end_inset

In addition to the rules already presented in the previous proof, we used
 some new rules in this proof, namely the reflexivity property of the equivalenc
e relation, as well as the 
\begin_inset Formula $+$
\end_inset

 and 
\begin_inset Formula $\times$
\end_inset

 rules: The latter two basically signify that sums and products can be split
 up in smaller parts whose equivalence is proven separately --- divide et
 impera.
\end_layout

\begin_layout Standard
Up to this point, we only considered grammars with a fixed number of producible
 words.
 That changes with the next example grammar, which produces an arbitrary
 number of different words.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:Recursive-grammar"

\end_inset

Consider the following grammar: 
\begin_inset Formula 
\begin{align*}
X & \to a+bX\\
Y & \to a+bY.
\end{align*}

\end_inset

We see that 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 produce the same language 
\begin_inset Formula $\lang X=\lang Y=b^{*}a$
\end_inset

.
 Therefore we prove 
\begin_inset Formula $X\equiv Y$
\end_inset

:
\begin_inset Formula 
\[
\bussproof{\transinf XY{\gr X{a+bX}}{\syminf{a+bX}Y{\transinf Y{a+bX}{\gr Y{a+bY}}{\plusinf{a+bY}{a+bX}{\refl aa}{\timesinf{bY}{bX}{\refl bb}{\syminf YX{\sj XY}}}}}}}
\]

\end_inset

The boxed judgement 
\begin_inset Formula $\boxed{X\equiv Y}$
\end_inset

 signifies that this judgement was already proven at a different place,
 which allows us to prove the equivalence of variables inductively.
 Note that the box around the judgement is just a visual aid to state that
 the judgement appears in the conclusion of a different rule; the box itself
 is by no means a distinct proof rule.
\end_layout

\begin_layout Standard
While references as in the example above allow use to reason inductively,
 it should be clear that we need to restrict such references in our proofs
 to keep our proof system sound; see the next example.
\end_layout

\begin_layout Example
Consider the following 
\begin_inset Quotes eld
\end_inset

proof
\begin_inset Quotes erd
\end_inset

:
\begin_inset Note Note
status open

\begin_layout Plain Layout
vertical alignment
\end_layout

\end_inset


\begin_inset Formula 
\[
\bussproof{\syminf XY{\syminf YX{\sj XY}}}
\]

\end_inset

This is obviously an invalid proof, as it would allow us otherwise to show
 the equivalence of any two variables.
 The reason why it is invalid is of course the boxed judgement 
\begin_inset Formula $\boxed{X\equiv Y}$
\end_inset

, which should not be applicable in such a context.
\end_layout

\begin_layout Standard
So the question is as follows: At which points may we refer to a judgement
 appearing in a conclusion at a different place?
\end_layout

\begin_layout Standard
We note that in both proofs above, we have a certain circularity, as 
\begin_inset Formula $X\equiv Y$
\end_inset

 appears once in a conclusion and once in a premise following from the conclusio
n.
 This circularity obviously leads to a contradiction for the second proof,
 whereas we claim that the first proof is correct.
 Why?
\end_layout

\begin_layout Standard
To show that the first proof is correct, let us assume that 
\begin_inset Formula $X\not\equiv Y$
\end_inset

.
 Then by definition there exists a smallest witness of non-equivalence of
 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

, 
\begin_inset Formula $w\in T^{+}$
\end_inset

.
 However, following the path from the conclusion 
\begin_inset Formula $X\equiv Y$
\end_inset

 to the premise 
\begin_inset Formula $X\equiv Y$
\end_inset

, we could find a smaller witness of non-equivalence, as there exists no
 rule which increases the norm when going from a conclusion to a premise,
 but there exists a rule which decreases the norm --- the product rule.
 As we then have a smaller witness of non-equivalence than 
\begin_inset Formula $w$
\end_inset

, this contradicts the fact that 
\begin_inset Formula $w$
\end_inset

 is the smallest witness.
 From this contradiction it follows that 
\begin_inset Formula $X\equiv Y$
\end_inset

 indeed holds.
\end_layout

\begin_layout Standard
Following this argumentation, we deduce that we can refer from one judgement
 to another judgement only
\begin_inset Note Note
status open

\begin_layout Plain Layout
discuss 
\begin_inset Quotes eld
\end_inset

only
\begin_inset Quotes erd
\end_inset

 with Cezary
\end_layout

\end_inset

 if on all paths between the two judgements, there is at least one instance
 of the 
\begin_inset Formula $\times$
\end_inset

 rule.
 We formalise this argument in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Soundness"

\end_inset

.
\end_layout

\begin_layout Section
Proof definition
\end_layout

\begin_layout Standard
Now we are ready to formally define equivalence proofs.
 After the definition, we explain it in depth.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:Proof-definition"

\end_inset

Let 
\begin_inset Formula $G=(V,T,P)$
\end_inset

 be a context-free grammar, 
\begin_inset Formula $\mathcal{P}$
\end_inset

 the set of simple polynomials over variables 
\begin_inset Formula $V$
\end_inset

 and terminals 
\begin_inset Formula $T$
\end_inset

, and 
\begin_inset Formula $\mathcal{J}\subset\mathcal{P}\times\mathcal{P}$
\end_inset

 the set of judgements over 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 We call 
\emph on

\begin_inset Formula $G$
\end_inset

-equivalence proof
\emph default
 of a judgement 
\begin_inset Formula $j\in\mathcal{J}$
\end_inset

 every finite set of rules 
\begin_inset Formula $\mathcal{R}$
\end_inset

, being instances of the proof rules in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Proof-rules"

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Schemes of non-strict rules:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\bussproof{\syminf xy{\axiom yx}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\bussproof{\transinf xz{\axiom xy}{\axiom yz}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\bussproof{\plusinf{x+y}{x'+y'}{\axiom x{x'}}{\axiom y{y'}}}$
\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Schemes of strict rules:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\bussproof{\refl xx}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\bussproof{\timesinf{x\cdot y}{x'\cdot y'}{\axiom x{x'}}{\axiom y{y'}}}$
\end_inset


\end_layout

\begin_layout Plain Layout
Strict rules:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\bussproof{\gr X{\Gr X}}$
\end_inset

, 
\begin_inset Formula $\forall X\in V$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Proof-rules"

\end_inset

Proof rules.
\end_layout

\end_inset


\end_layout

\end_inset

, such that
\begin_inset Formula 
\begin{equation}
\forall r\in\mathcal{R}:\,\left(\Concl r=j\lor\exists r'\in\mathcal{R}:\,\Concl r\in\Prem{r'}\right),\label{eq:Goal-proved}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\forall r_{1}\in\mathcal{R},\,\forall r_{2}\in\mathcal{R}:\,\Concl{r_{1}}=\Concl{r_{2}}\iff r_{1}=r_{2},\label{eq:Unique-conclusions}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\forall r\in\mathcal{R},\,\forall p\in\Prem r,\,\exists r_{p}\in\mathcal{R}:\,\left[p=\Concl{r_{p}}\land r\notin\Premstartimes{r_{p}}\right],\label{eq:Premises-proved}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Prem r$
\end_inset

 and 
\begin_inset Formula $\Concl r$
\end_inset

 denote the set of premises respectively conclusions of a rule 
\begin_inset Formula $r\in\mathcal{R}$
\end_inset

, and
\begin_inset Formula 
\[
\PremR r:=\left\{ r'\mid r'\in\mathcal{R}\land\Concl{r'}\in\Prem r\right\} ,
\]

\end_inset

 
\begin_inset Formula 
\[
\Premstartimes r:=\begin{cases}
\emptyset & r=\bussproof{\binaryinfc{\axiomc{P_{1}}}{\axiomc{P_{2}}}C{\ensuremath{\times}}};\\
r\cup\bigcup_{r_{p}\in\PremR r}\Premstartimes{r_{p}} & \mathrm{else}.
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Note Note
status open

\begin_layout Plain Layout
Make a pretty example to explain premstartimes.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us dissect this definition:
\end_layout

\begin_layout Enumerate
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Goal-proved"

\end_inset

, we demand that the conclusion of each proof rule must be either the judgement
 
\begin_inset Formula $j$
\end_inset

 (our final proof goal), or it must be in the premises of another proof
 rule.
 This ensures that there are no 
\begin_inset Quotes eld
\end_inset

dangling
\begin_inset Quotes erd
\end_inset

 rules, i.e.
 rules which are not related to the proof of 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Enumerate
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Unique-conclusions"

\end_inset

 we demand that there can not exist two different rules in the same proof
 having equal conclusions.
 This makes it possible to always find one unique proof rule given a judgement.
\end_layout

\begin_layout Enumerate
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Premises-proved"

\end_inset

, we demand that for each premise 
\begin_inset Formula $p$
\end_inset

 of a rule 
\begin_inset Formula $r$
\end_inset

, there exists another rule 
\begin_inset Formula $r_{p}$
\end_inset

 having the premise 
\begin_inset Formula $p$
\end_inset

 as conclusion.
 Furthermore, all possible 
\begin_inset Quotes eld
\end_inset

paths
\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Formula $r$
\end_inset

 to 
\begin_inset Formula $r_{p}$
\end_inset

 have to pass at least one instance of the 
\begin_inset Formula $\times$
\end_inset

 rule.
\end_layout

\begin_layout Standard
We express the last property with the help of two functions:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\PremR r$
\end_inset

 denotes all rules whose conclusions are equal to a premise of 
\begin_inset Formula $r$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Unique-conclusions"

\end_inset

, this function will thus return exactly one rule for each premise of 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Premstartimes r$
\end_inset

 informally returns 
\begin_inset Formula $r$
\end_inset

 and all rules 
\begin_inset Quotes eld
\end_inset

above
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $r$
\end_inset

 in the proof tree until an instance of the 
\begin_inset Formula $\times$
\end_inset

 rule is encountered.
\end_layout

\begin_layout Section
Soundness
\begin_inset CommandInset label
LatexCommand label
name "sec:Soundness"

\end_inset


\end_layout

\begin_layout Theorem
Each inference rule in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Proof-rules"

\end_inset

 is sound.
\begin_inset CommandInset label
LatexCommand label
name "th:Local-soundness"

\end_inset


\end_layout

\begin_layout Proof
We prove for each inference rule:
\end_layout

\begin_deeper
\begin_layout Itemize
Symmetry: 
\begin_inset Formula $\bussproof{\syminf xy{\axiom yx}}$
\end_inset


\begin_inset Newline newline
\end_inset

From 
\begin_inset Formula $y\equiv x$
\end_inset

, it follows 
\begin_inset Formula $\lang x=\lang y$
\end_inset

, which implies 
\begin_inset Formula $x\equiv y$
\end_inset

.
\end_layout

\begin_layout Itemize
Transitivity: 
\begin_inset Formula $\bussproof{\transinf xz{\axiom xy}{\axiom yz}}$
\end_inset


\begin_inset Newline newline
\end_inset

From 
\begin_inset Formula $x\equiv y$
\end_inset

 and 
\begin_inset Formula $y\equiv z$
\end_inset

, it follows that 
\begin_inset Formula $\lang x=\lang y$
\end_inset

 and 
\begin_inset Formula $\lang y=\lang z$
\end_inset

, so 
\begin_inset Formula $\lang x=\lang z$
\end_inset

, which implies 
\begin_inset Formula $x\equiv z$
\end_inset

.
\end_layout

\begin_layout Itemize
Sum: 
\begin_inset Formula $\bussproof{\plusinf{x+y}{x'+y'}{\axiom x{x'}}{\axiom y{y'}}}$
\end_inset


\begin_inset Newline newline
\end_inset

From 
\begin_inset Formula $x\equiv x'$
\end_inset

 and 
\begin_inset Formula $y\equiv y'$
\end_inset

, it follows that 
\begin_inset Formula $\lang x=\lang{x'}$
\end_inset

 and 
\begin_inset Formula $\lang y=\lang{y'}$
\end_inset

.
 Therefore, 
\begin_inset Formula $\lang{x+y}=\lang x\cup\lang y=\lang{x'}\cup\lang{y'}=\lang{x'+y'}$
\end_inset

 implies 
\begin_inset Formula $x+y\equiv x'+y'$
\end_inset

.
\end_layout

\begin_layout Itemize
Reflexivity: 
\begin_inset Formula $\bussproof{\refl xx}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\lang x=\lang x$
\end_inset

 is a tautology, so 
\begin_inset Formula $x\equiv x$
\end_inset

 always holds.
\end_layout

\begin_layout Itemize
Product: 
\begin_inset Formula $\bussproof{\timesinf{x\cdot y}{x'\cdot y'}{\axiom x{x'}}{\axiom y{y'}}}$
\end_inset


\begin_inset Newline newline
\end_inset

From 
\begin_inset Formula $x\equiv x'$
\end_inset

 and 
\begin_inset Formula $y\equiv y'$
\end_inset

, it follows that 
\begin_inset Formula $\lang x=\lang{x'}$
\end_inset

 and 
\begin_inset Formula $\lang y=\lang{y'}$
\end_inset

.
 Therefore, 
\begin_inset Formula $\lang{x\cdot y}=\lang x\cdot\lang y=\lang{x'}\cdot\lang{y'}=\lang{x'\cdot y'}$
\end_inset

 implies 
\begin_inset Formula $x\cdot y\equiv x'\cdot y'$
\end_inset

.
\end_layout

\begin_layout Itemize
Grammar: 
\begin_inset Formula $\bussproof{\gr X{\Gr X}}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\lang X=\lang{\Gr X}$
\end_inset

 holds by lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Language-of-polynomial"

\end_inset

, so 
\begin_inset Formula $X\equiv\Gr X$
\end_inset

 holds.
\end_layout

\end_deeper
\begin_layout Definition
Given two polynomials 
\begin_inset Formula $p_{1},p_{2}\in\mathcal{P}$
\end_inset

, the cost function
\begin_inset Formula 
\[
c\left(p_{1},p_{2}\right):=\inf\left\{ \left|w\right|\mid w\in\lang{p_{1}}\Delta\lang{p_{2}}\right\} 
\]

\end_inset

expresses the length of the smallest witness of non-equivalence of 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

.
 We extend the cost function to judgements 
\begin_inset Formula $p_{1}\equiv p_{2}$
\end_inset

 such that
\begin_inset Formula 
\[
c\left(p_{1}\equiv p_{2}\right):=c\left(p_{1},p_{2}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Now we shall discuss another important matter which we have not touched
 so far; namely the difference between strict and non-strict rules:
\end_layout

\begin_layout Lemma
For all rules 
\begin_inset Formula $\bussproof{\trinaryinfc{\axiomc{P_{1}}}{\axiomc{\dots}}{\axiomc{P_{n}}}C{rule}}$
\end_inset

 it holds that
\begin_inset Formula 
\[
\min\left\{ c\left(P_{1}\right),\dots,c\left(P_{n}\right)\right\} \leq c\left(C\right),
\]

\end_inset

and for all rules 
\begin_inset Formula $\bussproof{\binaryinfc{\axiomc{P_{1}}}{\axiomc{P_{2}}}C{\ensuremath{\times}}}$
\end_inset

 it even holds that
\begin_inset Formula 
\[
\min\left\{ c\left(P_{1}\right),c\left(P_{2}\right)\right\} <c\left(C\right)\text{ or }c\left(C\right)=\infty.
\]

\end_inset


\end_layout

\begin_layout Proof
Let us first assume that 
\begin_inset Formula $C$
\end_inset

 holds, implying 
\begin_inset Formula $c\left(C\right)=\infty$
\end_inset

.
 Then 
\begin_inset Formula $\min\left\{ c\left(P_{1}\right),\dots,c\left(P_{n}\right)\right\} \leq\infty$
\end_inset

 holds, which affirms the condition for all rules, and 
\begin_inset Formula $c\left(C\right)=\infty$
\end_inset

 holds also, which affirms the condition for 
\begin_inset Formula $\times$
\end_inset

 rules.
\end_layout

\begin_layout Proof
Now assume that 
\begin_inset Formula $C$
\end_inset

 does not hold, implying 
\begin_inset Formula $c\left(C\right)\neq\infty$
\end_inset

.
 We consider the different kinds of rules:
\end_layout

\begin_deeper
\begin_layout Itemize
Symmetry: 
\begin_inset Formula $\bussproof{\syminf xy{\axiom yx}}$
\end_inset


\begin_inset Newline newline
\end_inset

Here, we see that 
\begin_inset Formula $c\left(x,y\right)=c\left(y,x\right)$
\end_inset

, so 
\begin_inset Formula $\min\left\{ c\left(y,x\right)\right\} =c\left(y,x\right)\leq c\left(x,y\right)$
\end_inset

 holds.
\end_layout

\begin_layout Itemize
Transitivity: 
\begin_inset Formula $\bussproof{\transinf xz{\axiom xy}{\axiom yz}}$
\end_inset


\begin_inset Newline newline
\end_inset

Let us assume w.l.o.g.
 that the smallest witness of non-equivalence 
\begin_inset Formula $w$
\end_inset

 is contained in 
\begin_inset Formula $\lang x$
\end_inset

 and not in 
\begin_inset Formula $\lang z$
\end_inset

.
 Then we distinguish two cases:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x\equiv y$
\end_inset

 holds: As 
\begin_inset Formula $x\equiv z$
\end_inset

 does not hold, 
\begin_inset Formula $y\equiv z$
\end_inset

 can not hold.
 Furthermore, as 
\begin_inset Formula $\lang x=\lang y$
\end_inset

 by assumption, 
\begin_inset Formula $c\left(y,z\right)=c\left(x,z\right)$
\end_inset

, therefore 
\begin_inset Formula $\min\left\{ c\left(x,y\right),c\left(y,z\right)\right\} \leq c\left(y,z\right)\leq c\left(x,z\right)$
\end_inset

 holds.
\end_layout

\begin_layout Itemize
\begin_inset Formula $x\equiv y$
\end_inset

 does not hold: This means that 
\begin_inset Formula $c\left(x,y\right)\leq c\left(x,z\right)$
\end_inset

, as there might exist a smaller witness of non-equivalence 
\begin_inset Formula $w'\in\lang x\Delta\lang y$
\end_inset

, but the smallest witness can not be greater than 
\begin_inset Formula $w$
\end_inset

 in any case.
 Therefore 
\begin_inset Formula $\min\left\{ c\left(x,y\right),c\left(y,z\right)\right\} \leq c\left(y,z\right)\leq c\left(x,z\right)$
\end_inset

 holds as well.
\end_layout

\end_deeper
\begin_layout Itemize
Sum: 
\begin_inset Formula $\bussproof{\plusinf{x+y}{x'+y'}{\axiom x{x'}}{\axiom y{y'}}}$
\end_inset


\begin_inset Newline newline
\end_inset

Let us assume w.l.o.g.
 that the smallest witness 
\begin_inset Formula $w\in\lang{x+y}\Delta\lang{x'+y'}$
\end_inset

 is in 
\begin_inset Formula $\lang x$
\end_inset

.
 Then by assumption 
\begin_inset Formula $w\not\in\lang{x'}$
\end_inset

, which means that 
\begin_inset Formula $c\left(x,x'\right)=c\left(x+y,x'+y'\right)$
\end_inset

.
 Therefore 
\begin_inset Formula $\min\left\{ c\left(x,x'\right),c\left(y,y'\right)\right\} \leq c\left(x,x'\right)\leq c\left(x+y,x'+y'\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Product: 
\begin_inset Formula $\bussproof{\timesinf{x\cdot y}{x'\cdot y'}{\axiom x{x'}}{\axiom y{y'}}}$
\end_inset


\begin_inset Newline newline
\end_inset

Let us assume w.l.o.g.
 that the smallest witness 
\begin_inset Formula $w\in\lang{x\cdot y}\Delta\lang{x'\cdot y'}$
\end_inset

 is in 
\begin_inset Formula $\lang{x\cdot y}$
\end_inset

.
 Then 
\begin_inset Formula $w=w_{x}w_{y}$
\end_inset

 with 
\begin_inset Formula $w_{x}\in\lang x$
\end_inset

 and 
\begin_inset Formula $w_{y}\in\lang y$
\end_inset

, furthermore 
\begin_inset Formula $\left|w\right|=c\left(C\right)$
\end_inset

.
 Now we distinguish two cases:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $w_{x}\not\in\lang{x'}$
\end_inset

: We conclude that 
\begin_inset Formula $w_{x}\in\lang x\Delta\lang{x'}$
\end_inset

.
 As 
\begin_inset Formula $\left|w_{x}\right|<\left|w\right|$
\end_inset

, it follows that 
\begin_inset Formula $c\left(x,x'\right)\leq\left|w_{x}\right|<\left|w\right|=c\left(xy,x'y'\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $w_{x}\in\lang{x'}$
\end_inset

: We conclude that 
\begin_inset Formula $w_{y}\not\in\lang{y'}$
\end_inset

.
 As 
\begin_inset Formula $\left|w_{y}\right|<\left|w\right|$
\end_inset

, it follows that 
\begin_inset Formula $c\left(y,y'\right)\leq\left|w_{y}\right|<\left|w\right|=c\left(xy,x'y'\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
The reflexivity and grammar rules do not have any premises, which means
 the property for these rules is true.
\end_layout

\end_deeper
\begin_layout Theorem
The proof system in definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:Proof-definition"

\end_inset

 is sound.
\end_layout

\begin_layout Proof
As shown in theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "th:Local-soundness"

\end_inset

, all proof rules are locally sound.
 Therefore we have to verify that a set of valid proof rules satisfying
 the conditions in definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:Proof-definition"

\end_inset

 form a valid proof.
\end_layout

\begin_layout Proof
Let us argue by contradiction: Assume that the proof system is unsound.
 Then there exists a judgement 
\begin_inset Formula $p_{1}\equiv p_{2}$
\end_inset

 which has a proof in the proof system, but does not hold.
 If 
\begin_inset Formula $p_{1}\equiv p_{2}$
\end_inset

 does not hold, then 
\begin_inset Formula $c\left(p_{1},p_{2}\right)\neq\infty$
\end_inset

.
 As all proof rules are locally sound, we must have an invalid circular
 reference in that case.
 However, as a consequence of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Premises-proved"

\end_inset

, on all paths between a judgement in a conclusion and the same judgement
 in a premise, there exists at least one 
\begin_inset Formula $\times$
\end_inset

 rule, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Circular-proof"

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiomc{\dots\phantom{p}}}{\binaryinfc{\binaryinfc{\axiomc{\dots\phantom{p}}}{\binaryinfc{\axiomc{\dots}}{\axiom{p_{1}}{p_{2}}}{\dots\phantom{p}}{}}{\dots\phantom{p}}{\ensuremath{\times}}}{\axiomc{\phantom{p}\dots}}{\dots\phantom{p}}{}}{p_{1}}{p_{2}}{}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Circular-proof"

\end_inset

Illustration of a circular proof.
\end_layout

\end_inset


\end_layout

\end_inset

.
 Due to the 
\begin_inset Formula $\times$
\end_inset

 rule, the cost function strictly decreases along this path, therefore we
 must have that 
\begin_inset Formula $c\left(p_{1},p_{2}\right)<c\left(p_{1},p_{2}\right)$
\end_inset

, which is a contradiction.
\end_layout

\begin_layout Standard
We show completeness constructively, presenting our proof construction algorithm
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Proof-construction-algorithm"

\end_inset

 which we prove in the appendix to find an equivalence proof of two polynomials
 if the languages of the polynomials are equivalent.
\end_layout

\begin_layout Chapter
Proof construction strategies
\begin_inset CommandInset label
LatexCommand label
name "chap:Proof-construction-strategies"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we present several options to construct equivalence proofs
 of SDGs.
\end_layout

\begin_layout Section
Adaptation of existing algorithms
\end_layout

\begin_layout Standard
An adaptation of a polynomial-time algorithm to produce equivalence proofs,
 be it the Hirshfeld 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset

 or the Lasota 
\begin_inset CommandInset citation
LatexCommand cite
key "lasota2006"

\end_inset

 one, would have been very favourable, as this would have guaranteed a polynomia
l-time complexity of the resulting proof construction algorithm.
 However, due to the limited expressivity of our proof system, we found
 no way to express several critical functions of the aforementioned algorithms,
 such as lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Periodicity"

\end_inset

.
 We therefore deemed this option non feasible.
\end_layout

\begin_layout Section
Base replacement
\end_layout

\begin_layout Standard
Being unable to adapt the entire Hirshfeld algorithm to produce equivalence
 proofs, we noted that we could still use one of the main concepts of the
 algorithm, namely the Caucal base.
\end_layout

\begin_layout Standard
Our first idea to use the Caucal base was to find the list of equivalences
 in the base and to prove each one separately.
 As the number of elements in the base is quadratic, we only had to verify
 whether the proof of each element in the base is of polynomial size or
 not.
 The idea was to look at the first variables on both sides of a judgement,
 and to replace the variable with the greater norm with the associated base
 equivalence.
 For example, if we would encounter an equivalence like 
\begin_inset Formula $AB\equiv CD$
\end_inset

 with 
\begin_inset Formula $\norm A>\norm C$
\end_inset

, then we would replace 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $C\left[A\right]_{\norm C}$
\end_inset

 via transitivity in the proof.
 We detail the exact proof construction tactic in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Proof-strategy-2"

\end_inset

.
 Unfortunately, we soon had to conclude with the following lemma.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:Base-replacement-exp"

\end_inset

The base replacement tactic may produce proofs of exponential size.
\end_layout

\begin_layout Proof
To make the argument in this proof easier to read, we introduce two auxiliary
 proof rules:
\end_layout

\begin_deeper
\begin_layout Itemize
gr*: This rule replaces the first variable of the left or the right side
 of the conclusion by its grammar.
 For example:
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom{\Gr AB}{CD}}{AB}{CD}{gr*}}\quad\equiv\quad\bussproof{\transinf{AB}{CD}{\timesinf{AB}{\Gr AB}{\gr A{\Gr A}}{\refl BB}}{\axiom{\Gr A\cdot B}{CD}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\times^{*}$
\end_inset

: If one side of a judgement starts with a variable and the other side starts
 with the grammar of that variable, this rule eliminates variable and grammar
 from both sides.
 For example:
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom BD}{AB}{\Gr A\cdot D}{\ensuremath{\times^{*}}}}\quad\equiv\quad\bussproof{\timesinf{AB}{\Gr A\cdot D}{\gr A{\Gr A}}{\axiom BD}}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Proof
Now we consider the grammar given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:AB-grammar-non2NF"

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\begin{aligned}A & \to a & A & \to a\\
B & \to b & B & \to b\\
A_{B,0} & \to aB & B_{A,0} & \to bA\\
A_{B,n+1} & \to aBA_{B,n}A_{B,n} & B_{A,n+1} & \to bAB_{A,n}B_{A,n}\\
F_{n} & \to aBA_{B,n} & G_{n} & \to aB_{A,n}B
\end{aligned}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:AB-grammar-non2NF"

\end_inset


\begin_inset Formula $F_{n}\equiv G_{n}$
\end_inset

.
 
\begin_inset Formula $\norm{F_{n}}=\norm{G_{n}}=2^{n+2}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

, where we want to prove 
\begin_inset Formula $F_{n}\equiv G_{n}$
\end_inset

.
 We start as follows:
\begin_inset Formula 
\[
\bussproof{\grstar{F_{n}}{G_{n}}{\grstar{aBA_{B,n}}{G_{n}}{\timesinf{aBA_{B,n}}{aB_{A,n}B}{\refl aa}{\axiom{BA_{B,n}}{B_{A,n}B}}}}}
\]

\end_inset

After this initial step, the base replacement algorithm dictates that we
 must continuously apply the proof schemes given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Proof-schemes-base-replacement"

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\bussproof{\grstar{BA_{B,n+1}X}{B_{A,n+1}YB}{\timesstarinf{BA_{B,n+1}X}{bAB_{A,n}B_{A,n}YB}{\grstar{A_{B,n+1}X}{AB_{A,n}B_{A,n}YB}{\timesstarinf{aBA_{B,n}A_{B,n}X}{AB_{A,n}B_{A,n}YB}{\axiom{BA_{B,n}A_{B,n}X}{B_{A,n}B_{A,n}YB}}}}}}$
\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Formula $\bussproof{\grstar{BA_{B}^{0}X}{B_{A}^{0}YB}{\timesstarinf{BA_{B}^{0}X}{bAYB}{\grstar{A_{B}^{0}X}{AYB}{\timesstarinf{aBX}{AYB}{\axiom{BX}{YB}}}}}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Proof-schemes-base-replacement"

\end_inset

Proof schemes for base replacement algorithm.
\end_layout

\end_inset


\end_layout

\end_inset

, until we have to apply the reflexivity rule at the very end of the proof.
 We note that in both proof schemes, the norm of the last equality is by
 two smaller than the norm of the first equality, which means that we have
 to apply the proof schemes a number of times linear in the norm of the
 original equivalence.
 As the norm is exponential in the number of variables, we obtain a proof
 of exponential size.
\end_layout

\begin_layout Section
Decomposition
\end_layout

\begin_layout Standard
After noting that the base replacement idea would produce exponential-size
 proofs even for compression grammars, we thought of new methods.
 In turn, we discovered a function, which we dubbed 
\emph on
decomposition
\emph default
 and which shall be in the centre of this section.
 We first define the decomposition function:
\end_layout

\begin_layout Definition
The decomposition function is a partial function from 
\begin_inset Formula $V^{*}\times\mathbb{N}$
\end_inset

 to 
\begin_inset Formula $V^{*}$
\end_inset

, which returns 
\begin_inset Formula $\bot$
\end_inset

 if undefined.
\begin_inset Formula 
\begin{align*}
\left\langle \alpha\right\rangle _{0} & =\varepsilon;\\
\left\langle X_{i}\alpha\right\rangle _{t} & =\begin{cases}
V_{a_{i1}} & t=1\land\Gr{X_{i}}=a_{i1}\alpha_{i1};\\
V_{a_{i1}}\left\langle \alpha_{i1}\right\rangle _{t-1} & 1<t<\norm{X_{i}}\land\Gr{X_{i}}=a_{i1}\alpha_{i1};\\
X_{i}\left\langle \alpha\right\rangle _{t-\norm{X_{i}}} & \norm{X_{i}}\leq t\leq\norm{X_{i}\alpha};\\
\bot & \mathrm{else}.
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Given a variable word 
\begin_inset Formula $u\in V^{*}$
\end_inset

, we can calculate 
\begin_inset Formula $\left\langle u\right\rangle _{t}$
\end_inset

.
 If 
\begin_inset Formula $\left\langle u\right\rangle _{t}$
\end_inset

 is defined, then 
\begin_inset Formula $\norm{\left\langle u\right\rangle _{t}}=t$
\end_inset

 and 
\begin_inset Formula $\lang{\left\langle u\right\rangle _{t}}=L_{1}$
\end_inset

, where 
\begin_inset Formula $\lang u=L_{1}\cdot L_{2}$
\end_inset

 for some 
\begin_inset Formula $L_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Unlike the norm reduction function from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Hirshfeld-algorithm"

\end_inset

, the decomposition function tries not to determine the 
\emph on
postfix
\emph default
, but the 
\emph on
prefix
\emph default
 of a variable word with a certain norm.
 For example, if we know that 
\begin_inset Formula $AB\equiv CD$
\end_inset

 holds and 
\begin_inset Formula $\norm A>\norm C$
\end_inset

, then the algorithm in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Hirshfeld-algorithm"

\end_inset

 would try to find a postfix 
\begin_inset Formula $\alpha$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $A\equiv C\alpha$
\end_inset

.
 In contrast to this, we would use the decomposition function to calculate
 a prefix 
\begin_inset Formula $\beta=\left\langle D\right\rangle _{\norm A-\norm C}$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

 instead, such that
\end_layout

\begin_layout Itemize
\begin_inset Formula $\norm{\beta}=\norm A-\norm C$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $D\equiv\beta\cdot\gamma$
\end_inset

 for some 
\begin_inset Formula $\gamma$
\end_inset

, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $A\equiv C\beta$
\end_inset

.
\end_layout

\begin_layout Standard
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Decomposition-motivation"

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
svgwidth{200pt}
\end_layout

\begin_layout Plain Layout


\backslash
includesvg{ABCD-decomposition}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Decomposition-motivation"

\end_inset

Motivation for the decomposition function.
\end_layout

\end_inset


\end_layout

\end_inset

 for an illustration.
 Again, the main difference between decomposition and norm reduction is
 that we derive 
\begin_inset Formula $\beta$
\end_inset

 using the grammar of 
\begin_inset Formula $D$
\end_inset

, not of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Definition
Now we prove some properties of the decomposition function, analogous to
 
\begin_inset CommandInset citation
LatexCommand cite
key "hirshfeld1996"

\end_inset

.
 The most important properties are that decomposition returns valid prefixes
 of variables in case it does not return 
\begin_inset Formula $\bot$
\end_inset

, and that it returns only output of polynomial size.
\end_layout

\begin_layout Theorem
Decomposition has several properties:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\left\langle \alpha\right\rangle _{\norm{\alpha}}=\alpha$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}\leq\left(j-1\right)k+\length{\alpha}$
\end_inset

, where 
\begin_inset Formula $j$
\end_inset

 denotes the maximal index among all variables in 
\begin_inset Formula $\alpha$
\end_inset

 (or 
\begin_inset Formula $j=1$
\end_inset

 if 
\begin_inset Formula $\alpha=\varepsilon$
\end_inset

), and the grammar is in 
\begin_inset Formula $k$
\end_inset

-GNF.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\neq\bot$
\end_inset

, then 
\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\left[\alpha\right]_{t}\equiv\alpha$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
We prove one by one:
\end_layout

\begin_deeper
\begin_layout Enumerate
We prove 
\begin_inset Formula $\left\langle \alpha\right\rangle _{\norm{\alpha}}=\alpha$
\end_inset

 by induction on 
\begin_inset Formula $\alpha$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\alpha=\varepsilon$
\end_inset

: 
\begin_inset Formula $\left\langle \alpha\right\rangle _{\norm{\alpha}}=\left\langle \varepsilon\right\rangle _{0}=\varepsilon.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha=X_{i}\beta$
\end_inset

: 
\begin_inset Formula $\left\langle \alpha\right\rangle _{\norm{\alpha}}=\left\langle X_{i}\beta\right\rangle _{\norm{X_{i}\beta}}=X_{i}\left\langle \beta\right\rangle _{\norm{\beta}}\overset{\text{ind.}}{=}X_{i}\beta.$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
We prove 
\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}\leq\left(j-1\right)k+\length{\alpha}$
\end_inset

 by induction on 
\begin_inset Formula $t$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $t=0$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}=0$
\end_inset

.
 As 
\begin_inset Formula $j$
\end_inset

 is minimally 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 minimally 
\begin_inset Formula $0$
\end_inset

, we have that 
\begin_inset Formula $\left(j-1\right)k+\length{\alpha}\geq0$
\end_inset

.
 It follows that 
\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}\leq\left(j-1\right)k+\length{\alpha}$
\end_inset

 holds.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $t>0$
\end_inset

: We set 
\begin_inset Formula $\alpha=X_{i}\beta$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $t=1\land\Gr{X_{i}}=a_{i1}\alpha_{i1}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}=\length{V_{a_{i1}}}=1\leq\overbrace{\left(j-1\right)k}^{\geq0}+\overbrace{\length{\alpha}}^{\geq1}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $1<t<\norm{X_{i}}\land\Gr{X_{i}}=a_{i1}\alpha_{i1}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}=\length{V_{a_{i1}}\left\langle \alpha_{i1}\right\rangle _{t-1}}=1+\length{\left\langle \alpha_{i1}\right\rangle _{t-1}}\overset{\text{ind.}}{\leq}1+\left(i-1-1\right)k+k=1+\left(i-1\right)k\leq\left(i-1\right)k+\length{\alpha}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\norm{X_{i}}\leq t\leq\norm{X_{i}\beta}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\length{\left\langle \alpha\right\rangle _{t}}=\length{X_{i}\left\langle \beta\right\rangle _{t-\norm{X_{i}}}}=1+\length{\left\langle \beta\right\rangle _{t-\norm{X_{i}}}}\overset{\text{ind.}}{\leq}1+\left(j-1\right)k+\overbrace{\length{\alpha}-1}^{\length{\beta}}=\left(j-1\right)k+\length{\alpha}$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\neq\bot$
\end_inset

, then 
\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\left[\alpha\right]_{t}\equiv\alpha$
\end_inset

.
 We prove this by induction on 
\begin_inset Formula $t$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $t=0$
\end_inset

: 
\begin_inset Formula $\left\langle \alpha\right\rangle _{0}\left[\alpha\right]_{0}=\varepsilon\cdot\alpha\equiv\alpha$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $t>0$
\end_inset

: We set 
\begin_inset Formula $\alpha=X_{i}\beta$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $t=1\land\Gr{X_{i}}=a_{i1}\alpha_{i1}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $t\geq\norm{X_{i}}$
\end_inset

: It follows that 
\begin_inset Formula $\norm{X_{i}}=1$
\end_inset

, therefore 
\begin_inset Formula $\Gr{X_{i}}=a_{i1}$
\end_inset

 and 
\begin_inset Formula $\left\langle \alpha\right\rangle _{1}\left[\alpha\right]_{1}=\underbrace{V_{a_{i1}}}_{\equiv X_{i}}\cdot\left[\beta\right]_{\underbrace{t-\norm{X_{i}}}_{0}}=V_{a_{i1}}\cdot\beta\equiv X_{i}\beta$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $t<\norm{X_{i}}$
\end_inset

: 
\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\left[\alpha\right]_{t}=V_{a_{i1}}\cdot\left[\alpha_{i1}\right]_{\underbrace{t-1}_{0}}\cdot\beta=V_{a_{i1}}\alpha_{i1}\beta\equiv X_{i}\beta$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $1<t<\norm{X_{i}}\land\Gr{X_{i}}=a_{i1}\alpha_{i1}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\left[\alpha\right]_{t}=V_{a_{i1}}\left\langle \alpha_{i1}\right\rangle _{t-1}\left[\alpha_{i1}\right]_{t-1}\beta\overset{\text{ind.}}{=}V_{a_{i1}}\alpha_{i1}\beta\equiv X_{i}\beta$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\norm{X_{i}}\leq t\leq\norm{X_{i}\beta}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left\langle \alpha\right\rangle _{t}\left[\alpha\right]_{t}=X_{i}\left\langle \beta\right\rangle _{t-\norm{X_{i}}}=\left[\beta\right]_{t-\norm{X_{i}}}\overset{\text{ind.}}{=}X_{i}\beta$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
For compression grammars, if 
\begin_inset Formula $t\leq\norm X$
\end_inset

, then 
\begin_inset Formula $\left\langle X\right\rangle _{t}$
\end_inset

 will always succeed, i.e.
 not return 
\begin_inset Formula $\bot$
\end_inset

, because we do not allow sums in compression grammars.
\end_layout

\begin_layout Standard
However, if we look at general simple-deterministic grammars, we encounter
 cases where the decomposition will fail.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:Branching-grammar"

\end_inset

We want to prove 
\begin_inset Formula $AB\equiv PCD$
\end_inset

 for the following grammar
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that this grammar lacks the definition of some variables, but it should
 serve only the educational purpose of understanding the limitations of
 the decomposition function, for which the lacking variables play no role.
\end_layout

\end_inset

 with 
\begin_inset Formula $m>0$
\end_inset

:
\begin_inset Formula 
\begin{align*}
A_{n+1} & \to aA_{n}+bA_{n}\\
C_{n+1} & \to aC_{n}+bC_{n}\\
A_{0} & \to a\\
C_{0} & \to aX\\
A & \to aPA_{m}\\
C & \to aC_{m}\\
P & \to a
\end{align*}

\end_inset

The grammar is depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Branching-grammar"

\end_inset

: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
svgwidth{200pt}
\end_layout

\begin_layout Plain Layout


\backslash
includesvg{Branching_Grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Branching-grammar"

\end_inset

Branching grammar from example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:Branching-grammar"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

 In the upper and lower half of the image, there are graphical representations
 of 
\begin_inset Formula $PCD$
\end_inset

 and 
\begin_inset Formula $AB$
\end_inset

, respectively.
 In the upper half, we see by the tree structure that 
\begin_inset Formula $C$
\end_inset

 produces an exponential number of different words, which also holds true
 for 
\begin_inset Formula $A$
\end_inset

 in the lower half.
 However, we note that 
\begin_inset Formula $\norm{PC}$
\end_inset

 is greater than 
\begin_inset Formula $\norm A$
\end_inset

, while 
\begin_inset Formula $\norm P$
\end_inset

 alone is smaller than 
\begin_inset Formula $\norm A$
\end_inset

, which is why we want to calculate the prefix of 
\begin_inset Formula $PCD$
\end_inset

 with the norm of the variable 
\begin_inset Formula $A$
\end_inset

.
 What happens now if we try to do that? We get:
\begin_inset Formula 
\begin{align*}
\left\langle PCD\right\rangle _{\norm A} & =P\left\langle CD\right\rangle _{\norm A-1}\\
 & =PA_{0}\left\langle C_{m}D\right\rangle _{\norm A-2}\\
 & =\bot\text{, because }1<\norm A-2<\norm{C_{m}}\text{, but }\Gr{C_{m}}\text{ is a sum.}
\end{align*}

\end_inset

From the image, we get an intuition why the decomposition is bound to fail
 in this case: If we try to determine a prefix of 
\begin_inset Formula $C$
\end_inset

 which should be by 
\begin_inset Formula $\norm X$
\end_inset

 smaller than 
\begin_inset Formula $\norm C$
\end_inset

, we are bound to return an exponential number of different words.
 In that case it is better to fail directly by returning 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Standard
That is a realistic scenario in a proof, so what can we do to remedy this
 problem? We cannot easily fix the decomposition function to not return
 
\begin_inset Formula $\bot$
\end_inset

 in such cases, as it would have to return a potentially exponentially big
 sum of words otherwise, which is certainly not desirable.
 Our answer to this problem is the base: In cases where the decomposition
 is not applicable, we employ the base.
 E.g.
 in the example above, after determining that 
\begin_inset Formula $\left\langle PCD\right\rangle _{\norm A}$
\end_inset

 yields 
\begin_inset Formula $\bot$
\end_inset

, we postulate that 
\begin_inset Formula $A\equiv P\left[C\right]_{\norm P}$
\end_inset

, and in fact 
\begin_inset Formula $\left[C\right]_{\norm P}$
\end_inset

 will be equivalent to 
\begin_inset Formula $C_{m}$
\end_inset

.
\end_layout

\begin_layout Chapter
Proof construction algorithm
\begin_inset CommandInset label
LatexCommand label
name "chap:Proof-construction-algorithm"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
relation to other work ...
\end_layout

\end_inset

In this chapter, we present our algorithm, which tries to construct an equivalen
ce proof given a grammar and a judgement.
\end_layout

\begin_layout Standard
The main algorithm basically implements a depth-first search
\begin_inset Note Note
status open

\begin_layout Plain Layout
reference?
\end_layout

\end_inset

, during which it keeps a growing list of already proven judgements.
 The algorithm works recursively: It accepts a sequence 
\begin_inset Formula $rules$
\end_inset

 of given proof rules, and a sequence 
\begin_inset Formula $toprove$
\end_inset

 consisting of judgements to prove.
 If there are no judgements left to prove, we return 
\begin_inset Formula $rules$
\end_inset

, which contains the final proof.
 Otherwise, we look at the first judgement to prove and construct a proof
 rule 
\begin_inset Formula $r$
\end_inset

 for it, whose conclusion 
\begin_inset Formula $\Concl r$
\end_inset

 will be equivalent to the judgement.
 From this proof rule 
\begin_inset Formula $r$
\end_inset

, we now take its premises and sort out those which have already been proven
 by other already existing proof rules.
 We add the remaining unproven premises 
\begin_inset Formula $p$
\end_inset

 of 
\begin_inset Formula $r$
\end_inset

 to the rest of the judgements to prove and call the algorithm again, with
 our new rule added to the previous 
\begin_inset Formula $rules$
\end_inset

.
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Function{prove}{$rules, toprove$}
\backslash
Comment{construct proof}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$toprove=
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
textbf{return} $rules$
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State $r
\backslash
gets 
\backslash
Call{rule}{
\backslash
Call{hd}{toprove}}$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $p
\backslash
gets 
\backslash
Call{premises}{r} 
\backslash
backslash 
\backslash
Call{conclusions}{rules}$ 
\backslash
Comment{unproven premises}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
textbf{return} $
\backslash
Call{prove}{rules @ r, p @ 
\backslash
Call{tl}{toprove}}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\backslash
label{euclidendwhile}
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Proof algorithm.
\end_layout

\end_inset


\end_layout

\end_inset

The functions used in our algorithm are:
\end_layout

\begin_layout Itemize

\noun on
rule
\noun default
 returns a proof rule for a given judgement, which will be the conclusion
 of the new proof rule.
 Note that this function works purely locally, meaning it does not have
 any other information than the grammar and the current judgement to prove;
 for example, it does not dispose of the information which judgements have
 already been proven.
\end_layout

\begin_layout Itemize

\noun on
hd
\noun default
 and 
\noun on
tl
\noun default
 return the head respectively tail of a sequence.
\end_layout

\begin_layout Itemize

\noun on
premises
\noun default
 returns all premises of a given rule.
\end_layout

\begin_layout Itemize

\noun on
conclusions
\noun default
 returns the set of all conclusions of a sequence of rules.
\end_layout

\begin_layout Itemize
The operator @ concatenates two sequences.
\end_layout

\begin_layout Itemize
\begin_inset Formula $a\backslash b$
\end_inset

 returns all items of 
\begin_inset Formula $a$
\end_inset

 which are not in 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\begin_layout Standard
The only non-trivial function of the algorithm is 
\noun on
rule
\noun default
.
 For comparison reasons, we implemented several different versions of 
\noun on
rule
\noun default
, which we called proof tactics:
\end_layout

\begin_layout Enumerate
The first proof tactic we developed (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Proof-strategy-1"

\end_inset

) combines base replacement with decomposition.
\end_layout

\begin_layout Enumerate
To measure the impact of the decomposition on the proof size, we also developed
 a second tactic (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Proof-strategy-2"

\end_inset

), which uses only base replacement without making use of the decomposition.
\end_layout

\begin_layout Enumerate
We also briefly considered writing a proof tactic using neither base replacement
 nor decomposition, only rewriting judgements with the given grammar rules,
 but it soon turned out that it would require significant adaptations to
 our current algorithm.
 Also given the predictably horrendous performance (if it were terminating,
 which is not sure) of the tactic, we chose not to implement it.
\end_layout

\begin_layout Section
Proof tactic 1
\begin_inset CommandInset label
LatexCommand label
name "sec:Proof-strategy-1"

\end_inset


\end_layout

\begin_layout Standard
The first proof tactic uses base replacement and decomposition to construct
 a proof rule from a given judgement.
 We construct proof rules bottom-up, which means that for a given judgement,
 we try to find a proof rule which has the given judgement as conclusion.
\end_layout

\begin_layout Standard
We use the following conventions for variable names:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A,B,A_{n},B_{m}\in V$
\end_inset

 are variables,
\end_layout

\begin_layout Itemize
\begin_inset Formula $P,Q\in V^{+}$
\end_inset

 are non-empty variable words,
\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{n},Q_{m}\in V^{*}$
\end_inset

 are (possibly empty) variable words, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $a,b,a_{n},b_{m}\in T$
\end_inset

 are terminals.
\end_layout

\begin_layout Standard
Furthermore, we use the following abbreviations, where 
\begin_inset Formula $n_{A}$
\end_inset

 designates the number of factors/addends in the respective products/sums:
\begin_inset Formula 
\begin{align*}
\prod A_{x} & \equiv\prod_{x=1}^{n_{A}>1}A_{x},\\
\sum a_{x}A_{x} & \equiv\sum_{x=1}^{n_{A}>1}a_{x}A_{x}.
\end{align*}

\end_inset

The tactic rules are named according to the type of judgement to prove:
\end_layout

\begin_layout Itemize
'p' stands for product of a single variable,
\end_layout

\begin_layout Itemize
'P' for product of multiple variables,
\end_layout

\begin_layout Itemize
's' for sum of one term, and
\end_layout

\begin_layout Itemize
'S' for sum of multiple terms.
\end_layout

\begin_layout Standard
For example, if we have to prove 
\begin_inset Formula $A\equiv aB_{1}+bB_{2}$
\end_inset

, we look for the tactic rule pS, because 
\begin_inset Formula $A$
\end_inset

 is a single variable ('p') and 
\begin_inset Formula $aB_{1}+bB_{2}$
\end_inset

 is a sum of multiple terms ('S').
 In this case, however, there exists no tactic rule pS, but only the tactic
 rule psS, which indicates that it handles the cases ps and pS.
 Similarly the tactic rule sSpP, which handles the cases sp, sP, Sp and
 SP.
\end_layout

\begin_layout Standard
For several judgement types, there exist multiple tactic rules, which we
 apply depending on if their conditions are fulfilled.
 If there are several tactic rules for one judgement type, we name them
 accordingly based on the performed action:
\end_layout

\begin_layout Itemize
B: base replacement
\end_layout

\begin_layout Itemize
D: decomposition replacement
\end_layout

\begin_layout Itemize
G: grammar replacement
\end_layout

\begin_layout Itemize
S: symmetry
\end_layout

\begin_layout Itemize
V: variable replacement
\end_layout

\begin_layout Itemize
\begin_inset Formula $\times$
\end_inset

: product
\end_layout

\begin_layout Standard
Now we present the tactic rules:
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Refl: If we encounter a judgement where both sides are equal, we apply this
 rule.
 This rule has highest precedence, which means that for all other rules,
 we can assume left- and right-hand sides of the conclusion to be unequal.
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiomc{}}EE{\text{refl (Refl)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
Gr: If the right-hand side equals the grammar of the variable on the left-hand
 side, we apply this rule.
 
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiomc{}}A{\Gr A}{\text{gr (Gr)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
pp: This rule replaces the variable on the left-hand side by its grammar.
 
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiom A{\Gr A}}{\axiom{\Gr A}B}AB{\text{trans (pp)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
pP-
\begin_inset Formula $\bot$
\end_inset

: If the norm 
\begin_inset Formula $\norm A$
\end_inset

 of the variable on the left-hand side is smaller/equal the norm 
\begin_inset Formula $\norm{B_{1}}$
\end_inset

 of the first variable on the right-hand side, then 
\begin_inset Formula $\norm A<\norm{\prod B_{y}}$
\end_inset

, which is a contradiction.
 
\begin_inset Formula 
\begin{gather*}
\norm A\leq\norm{B_{1}}\implies\\
\bussproof{\unaryinf{\axiomc{\bot}}A{\prod B_{y}}{\ensuremath{\bot}\text{ (pP-\ensuremath{\bot})}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
pP-B: Given we do not produce any invalid circularity, we use the base to
 substitute the variable on the left-hand side.
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm A & >\norm{B_{1}},\\
\left[A\right]_{\norm{B_{1}}} & \neq\prod_{y=2}^{n_{B}}B_{y}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom A{B_{1}\left[A\right]_{\norm{B_{1}}}}}{\axiom{B_{1}\left[A\right]_{\norm{B_{1}}}}B}A{\prod B_{y}}{\text{trans (pP-B)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
pP-G: If we cannot replace the right-hand side with the base (possibly because
 we have executed a base replacement before), we replace the variable on
 the left-hand side with its grammar.
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm A & >\norm{B_{1}},\\
\left[A\right]_{\norm{B_{1}}} & =\prod_{y=2}^{n_{B}}B_{y}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom A{\Gr A}}{\axiom{\Gr A}B}A{\prod B_{y}}{\text{trans (pP-G)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
psS: If we encounter a sum of one or multiple terms on the right-hand side
 and a single variable on the left hand-side, we replace the single variable
 by its grammar:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiom A{\Gr A}}{\axiom{\Gr A}B}A{\sum_{y=1}^{n_{B}\geq1}b_{y}Q_{y}}{\text{trans (psS)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
Pp: To avoid having rules like Pp-B and Pp-G, which would be symmetrical
 to pP-B and pP-G, we use the symmetry rule, after which the resulting judgement
 will be treated by a pP rule.
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom B{\prod A_{x}}}{\prod A_{x}}B{\text{sym (Pp)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
PP-S: In all following PP rules, we assume that the first variable on the
 left-hand side has a greater or equal norm than the first variable on the
 right-hand side; we assure that condition with this rule.
 
\begin_inset Formula 
\begin{gather*}
\norm{A_{1}}<\norm{B_{1}}\implies\\
\bussproof{\unaryinf{\axiom{\prod B_{y}}{\prod A_{x}}}{\prod A_{x}}{\prod B_{y}}{\text{sym (PP-S)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
PP-D: If the decomposition of the right-hand side with the norm of the first
 variable on the left-hand side is defined and we can replace the first
 variable on the left-hand side with the decomposition, we apply this rule.
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm{A_{1}} & \geq\norm{B_{1}},\\
D & =\left\langle \prod B_{y}\right\rangle _{\norm{A_{1}}},\\
D & \neq\bot,\\
\lnot\exists c<n_{B}:\, D & =\prod_{y=1}^{c}B_{y}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom{\prod A_{x}}{D\prod_{x=2}^{n_{A}}A_{x}}}{\axiom{D\prod_{x=2}^{n_{A}}A_{x}}{\prod B_{y}}}{\prod A_{x}}{\prod B_{y}}{\text{trans (PP-D)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
PP-
\begin_inset Formula $\times$
\end_inset

: If the decomposition of the right-hand side with the norm of the first
 variable on the left-hand side is defined, but is equal to a part of the
 right-hand side, then we use the product rule.
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm{A_{1}} & \geq\norm{B_{1}},\\
D & =\left\langle \prod B_{y}\right\rangle _{\norm{A_{1}}},\\
D & \neq\bot,\\
\exists c<n_{B}:\, D & =\prod_{y=1}^{c}B_{y}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom{A_{1}}{\prod_{y=1}^{c}B_{y}}}{\axiom{\prod_{x=2}^{n_{A}}A_{x}}{\prod_{y=c+1}^{n_{B}}B_{y}}}{\prod A_{x}}{\prod B_{y}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}
\end{gather*}

\end_inset

Note that this rule also handles the case where 
\begin_inset Formula $A_{1}$
\end_inset

 is equal to 
\begin_inset Formula $B_{1}$
\end_inset

, e.g.
 
\begin_inset Formula $XY\equiv XZ$
\end_inset

.
\end_layout

\begin_layout Itemize
PP-B: If the decomposition yields 
\begin_inset Formula $\bot$
\end_inset

, we resort to base replacement.
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm{A_{1}} & \geq\norm{B_{1}},\\
D & =\left\langle \prod B_{y}\right\rangle _{\norm{A_{1}}},\\
D & =\bot,\\
R & =B_{1}\left[A_{1}\right]_{\norm{B_{1}}}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom{\prod A_{x}}{R\prod_{x=2}^{n_{A}}A_{x}}}{\axiom{R\prod_{x=2}^{n_{A}}A_{x}}{\prod B_{y}}}{\prod A_{x}}{\prod B_{y}}{\text{trans (PP-B)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
Ps-S: This gets picked up by the ssSP rule, which will produce a contradiction.
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom b{\prod A_{x}}}{\prod A_{x}}b{\text{sym (Ps-S)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
Ps-
\begin_inset Formula $\times$
\end_inset

: If the norm of the first variable on the left-hand side is 1 and the right-han
d side is a sum of a single term, then we can split the product and the
 sum.
 
\begin_inset Formula 
\begin{gather*}
\norm{A_{1}}=1\implies\\
\bussproof{\binaryinf{\axiom{A_{1}}b}{\axiom{\prod_{x=2}^{n_{A}}A_{x}}Q}{\prod A_{x}}{bQ}{\ensuremath{\times}\text{ (Ps-\ensuremath{\times})}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
Ps-V: If the norm of the first variable on the left-hand side is greater
 than 1, then we replace the sum on the right-hand side with an equivalent
 product.
 To achieve that, we use the terminal morphism to associate 
\begin_inset Formula $b$
\end_inset

 with an equivalent variable having exactly one production rule, namely
 
\begin_inset Formula $V_{b}\to b$
\end_inset

.
 
\begin_inset Formula 
\begin{gather*}
\norm{A_{1}}>1\implies\\
\bussproof{\binaryinf{\axiom{\prod A_{x}}{V_{b}Q}}{\axiom{V_{b}Q}{bQ}}{\prod A_{x}}{bQ}{\text{trans (Ps-V)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
PS-G: We replace the first variable on the left-hand side with its grammar,
 unless the result would be equal to the right-hand side.
\begin_inset Formula 
\begin{gather*}
\sum b_{y}B_{y}\neq\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}\implies\\
\bussproof{\binaryinf{\axiom{\prod A_{x}}{\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}}}{\axiom{\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}}{\sum b_{y}B_{y}}}{\prod A_{x}}{\sum b_{y}B_{y}}{\text{trans (PS-G)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
PS-
\begin_inset Formula $\times$
\end_inset

: If the sum on the right-hand side is equal to the left-hand side, after
 its first variable has been replaced by its grammar, we can apply the 
\begin_inset Formula $\times$
\end_inset

 rule.
 This is normally a result of the PS-G rule.
 
\begin_inset Formula 
\begin{gather*}
\sum b_{y}B_{y}=\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}\implies\\
\bussproof{\binaryinf{\axiom{A_{1}}{\Gr{A_{1}}}}{\axiom{\prod_{x=2}^{n_{A}}A_{x}}{\prod_{x=2}^{n_{A}}A_{x}}}{\prod A_{x}}{\sum b_{y}B_{y}}{\ensuremath{\times}\text{ (PS-\ensuremath{\times})}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
sSpP: We resort to the pPsS rules to treat this case.
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom Q{\sum a_{x}A_{x}}}{\sum_{x=1}^{n_{A}\geq1}a_{x}A_{x}}Q{\text{sym (sSpP)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
ssSP: If the left-hand side consists of only a terminal, then the right-hand
 side must either consist of the same terminal (which is treated by the
 refl rule) or by one single variable.
 Otherwise, we have a contradiction, as handles by this rule.
\begin_inset Formula 
\begin{gather*}
E\neq B\implies\\
\bussproof{\unaryinf{\axiomc{\bot}}aE{\ensuremath{\bot}\text{ (ssSP)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
ss-
\begin_inset Formula $\bot$
\end_inset

:
\begin_inset Formula 
\begin{gather*}
a\neq b\implies\\
\bussproof{\unaryinf{\axiomc{\bot}}{aP}{bQ}{\ensuremath{\bot}\text{ (ss-\bot)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
ss-S: We push this particular case to the ssSP rule, where it will cause
 a contradiction.
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom b{aP}}{aP}b{\text{sym (ss-S)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
ss-
\begin_inset Formula $\times$
\end_inset

: If the first terminals of the two sums are equivalent, we split the sums.
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiom aa}{\axiom PQ}{aP}{aQ}{\ensuremath{\times}\text{ (ss-\times)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
sS-
\begin_inset Formula $\bot$
\end_inset

: If we have sums on both sides of a judgement, their number of addends
 must coincide.
 This is obviously not the case here, so we have a contradiction.
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiomc{\bot}}{aP}{\sum b_{y}Q_{y}}{\ensuremath{\bot}\text{ (ss-\bot)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
SS-
\begin_inset Formula $\bot$
\end_inset

: If the first terminal on the left-hand side does not match any terminal
 on the right-hand side, we fail.
\begin_inset Formula 
\begin{gather*}
\lnot\left(\exists i:\, a_{1}=b_{i}\right)\implies\\
\bussproof{\unaryinf{\axiomc{\bot}}{\sum a_{x}A_{x}}{\sum b_{y}B_{y}}{\ensuremath{\bot}\text{ (SS-\bot)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
SS-
\begin_inset Formula $+$
\end_inset

: If we find a terminal on the right-hand side which is equivalent to the
 first terminal on the left-hand side, we split the sums.
 
\begin_inset Formula 
\begin{gather*}
\exists!i:\, a_{1}=b_{i}\implies\\
\bussproof{\binaryinf{\axiom{a_{1}A_{1}}{b_{i}B_{i}}}{\axiom{\sum_{x=2}^{n_{A}}a_{x}A_{x}}{\sum_{y=1}^{i-1}b_{y}B_{y}+\sum_{y=i+1}^{n_{B}}b_{y}B_{y}}}{\sum a_{x}A_{x}}{\sum b_{y}B_{y}}{\ensuremath{+}\text{ (SS-\ensuremath{+})}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The validity of the proof tactic is proven in the appendix.
\end_layout

\begin_layout Lemma
Given a judgement, the presented proof tactic constructs a proof rule with
 its conclusion equalling the judgement in polynomial time.
\end_layout

\begin_layout Proof
The only non-trivial functions we use to decide which tactic rule to use,
 are norm, norm reduction and decomposition, which all terminate in polynomial
 time.
 This means that we can decide in polynomial time which tactic rule to apply.
\end_layout

\begin_layout Proof
Furthermore, the size of the premises of the new proof rule is also polynomial
 in the size of the conclusion, as the size of a premise can only become
 bigger than its conclusion with the transitivity rule.
 In that case we substitute a polynomial number of variables of the conclusion
 with other terms, for example the grammar of a variable or the decomposition
 of a variable word.
 Because these terms can always be calculated in polynomial time, the tactic
 constructs a proof rule in polynomial time.
\end_layout

\begin_layout Section
Proof tactic 2
\begin_inset CommandInset label
LatexCommand label
name "sec:Proof-strategy-2"

\end_inset


\end_layout

\begin_layout Standard
The second proof tactic does not use decomposition, but relies solely on
 base replacement.
 The greatest part of its tactic rules is equivalent to the rules in the
 first tactic; the differences lie only in the PP rules, where we replace
 PP-D, PP-
\begin_inset Formula $\times$
\end_inset

 and PP-B from the first tactic by the following rules:
\end_layout

\begin_layout Itemize
PP-
\begin_inset Formula $\times$
\end_inset

': This rule handles the case where a base replacement has already been
 performed on the given judgement to prove, which is why another base replacemen
t step would result in an invalid circularity.
 Luckily, we can directly apply 
\begin_inset Formula $\times$
\end_inset

 in such a case: 
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm{A_{1}} & \geq\norm{B_{1}},\\
R & =B_{1}\left[A_{1}\right]_{\norm{B_{1}}},\\
\exists c<n_{B}:\, R & =\prod_{y=1}^{c}B_{y}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom{A_{1}}{\prod_{y=1}^{c}B_{y}}}{\axiom{\prod_{x=2}^{n_{A}}A_{x}}{\prod_{y=c+1}^{n_{B}}B_{y}}}{\prod A_{x}}{\prod B_{y}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
PP-B': We execute base replacement when it does not result in an invalid
 circularity:
\begin_inset Formula 
\begin{gather*}
\begin{aligned}\norm{A_{1}} & \geq\norm{B_{1}},\\
R & =B_{1}\left[A_{1}\right]_{\norm{B_{1}}},\\
\lnot\exists c<n_{B}:\, R & =\prod_{y=1}^{c}B_{y}\implies
\end{aligned}
\\
\bussproof{\binaryinf{\axiom{\prod A_{x}}{R\prod_{x=2}^{n_{A}}A_{x}}}{\axiom{R\prod_{x=2}^{n_{A}}A_{x}}{\prod B_{y}}}{\prod A_{x}}{\prod B_{y}}{\text{trans (PP-B)}}}
\end{gather*}

\end_inset


\end_layout

\begin_layout Section
Optimisation ideas
\end_layout

\begin_layout Standard
During the development of our proof strategy, we considered several ideas
 to improve proof construction.
 We show a small excerpt of these ideas:
\end_layout

\begin_layout Itemize
If we have to prove for example 
\begin_inset Formula $A\equiv BCD$
\end_inset

 and 
\begin_inset Formula $A\equiv BCE$
\end_inset

, we might try to prove only 
\begin_inset Formula $A\equiv BCD$
\end_inset

 and then prove 
\begin_inset Formula $A\equiv BCE$
\end_inset

 by just showing 
\begin_inset Formula $D\equiv E$
\end_inset

 directly.
 The problem is that we might have several choices to choose from --- what
 do we do for example if we also have to prove 
\begin_inset Formula $A\equiv BCF$
\end_inset

? Do we then prove 
\begin_inset Formula $F\equiv D$
\end_inset

, or do we prove 
\begin_inset Formula $F\equiv E$
\end_inset

?
\end_layout

\begin_layout Itemize
Having to prove a judgement of the form 
\begin_inset Formula $X_{1}X_{2}\dots X_{l}\equiv Y_{1}Y_{2}\dots Y_{m}$
\end_inset

, we might try to find indices 
\begin_inset Formula $i,j$
\end_inset

 such that
\begin_inset Formula 
\[
\norm{X_{1}\dots X_{i}}=\norm{Y_{1}\dots Y_{j}},\,\norm{X_{i+1}\dots X_{l}}=\norm{Y_{j+1}\dots Y_{m}},
\]

\end_inset

thus producing two smaller judgements to prove.
\end_layout

\begin_layout Itemize
Having already proven 
\begin_inset Formula $X\equiv Y$
\end_inset

 and faced with the task of proving 
\begin_inset Formula $Y\equiv X$
\end_inset

, we might just apply the symmetry rule.
 For example, this would about halve the size of the proof in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Equivalence-Groof"

\end_inset

.
\end_layout

\begin_layout Standard
As we considered none of these ideas to have a fundamental impact on the
 complexity of our algorithm, we decided to first determine the complexity
 of our algorithm without these optimisation ideas.
\end_layout

\begin_layout Chapter
Implementation & experimental results
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation-Experiments"

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We wrote an OCaml program called 
\noun on
Groof
\begin_inset Foot
status open

\begin_layout Plain Layout
The name 
\noun on
Groof
\noun default
 is of course a clever pun referring to its respective homophone and to
 
\emph on
gr
\emph default
ammar pr
\emph on
oof
\emph default
s.
 Coincidentally, there also exists an Austrian musician named Carl de Groof
 (1923-2007), thereby further enriching the different significations of
 the name.
 The program is available at 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/01mf02/thesis"

\end_inset

.
\end_layout

\end_inset


\noun default
 (
\begin_inset CommandInset include
LatexCommand input
filename "programsize.txt"

\end_inset

lines of code) doing the following tasks:
\begin_inset Note Note
status open

\begin_layout Plain Layout
fix footnote!
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Grammar generation: The program constructs several different grammars with
 an adaptable number of variables, to compare the sizes of the resulting
 equivalence proofs.
\end_layout

\begin_layout Itemize
Grammar verification & norm calculation: The program verifies that the input
 grammar is a normalised simple deterministic grammar, and in the same turn
 calculates the norm of each variable.
\end_layout

\begin_layout Itemize
Proof construction: The program constructs an equivalence proof for a given
 judgement.
 For this, it may use any of the two tactics presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Proof-construction-algorithm"

\end_inset

.
\end_layout

\begin_layout Itemize
Proof verification: The program verifies whether the constructed proof is
 a valid proof according to definition 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:Proof-definition"

\end_inset

.
\end_layout

\begin_layout Itemize
Proof output: The program outputs the final proof as LaTeX code --- see
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Equivalence-Groof"

\end_inset

 for an example.
 
\begin_inset Float figure
wide false
sideways true
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\bussproof{\transinf XY{\gr X{a+bX}}{\syminf{a+bX}Y{\transinf Y{a+bX}{\gr Y{a+bY}}{\plusinf{a+bY}{a+bX}{\refl aa}{\timesinf{bY}{bX}{\refl bb}{\transinf YX{\sj Y{a+bY}}{\syminf{a+bY}X{\transinf X{a+bY}{\sj X{a+bX}}{\plusinf{a+bX}{a+bY}{\sj aa}{\timesinf{bX}{bY}{\sj bb}{\sj XY}}}}}}}}}}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Equivalence-Groof"

\end_inset

Equivalence proof of example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:Recursive-grammar"

\end_inset

, generated automatically by 
\noun on
Groof
\noun default
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Statistics: The program saves the proof sizes for each considered grammar.
\end_layout

\begin_layout Section
Benchmark grammars
\end_layout

\begin_layout Standard
Here we present the performance of our proof tactics with the aid of five
 different grammars, where 
\begin_inset Formula $n$
\end_inset

 is a parameter to adjust the grammar size:
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that in graphs, number of variables is in fact n!
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $2^{n}$
\end_inset

 grammar (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:2^n-grammar"

\end_inset

): 
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
S_{0} & \to a\\
S_{1} & \to aS_{0} & S_{1}^{'} & \to a\\
S_{n+2} & \to aS_{n+1}S_{n+1}^{'} & S_{n+2}^{'} & \to aS_{n+1}^{'}S_{n+1}^{'}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
T_{0} & \to a\\
T_{1} & \to aT_{0} & T_{1}^{'} & \to a\\
T_{n+2} & \to aT_{n+1}^{'}T_{n+1} & T_{n+2}^{'} & \to aT_{n+1}^{'}T_{n+1}^{'}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:2^n-grammar"

\end_inset


\begin_inset Formula $\norm{S_{n}}=\norm{T_{n}}=2^{n}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $S_{n}$
\end_inset

 and 
\begin_inset Formula $T_{n}$
\end_inset

 describe the language 
\begin_inset Formula $a^{2^{n}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Fibonacci grammar (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Fib-grammar"

\end_inset

): 
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
F_{0} & \to a\\
F_{1} & \to a\\
F_{2} & \to aF_{0} & F_{2}^{'} & \to a\\
F_{n+3} & \to aF_{n+1}F_{n+2}^{'} & F_{3}^{'} & \to aF_{2}^{'}\\
 &  & F_{n+4}^{'} & \to aF_{n+2}^{'}F_{n+3}^{'}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
G_{0} & \to a\\
G_{1} & \to a\\
G_{2} & \to aG_{0} & G_{2}^{'} & \to a\\
G_{n+3} & \to aG_{n+2}^{'}G_{n+1} & G_{3}^{'} & \to aG_{2}^{'}\\
 &  & G_{n+4}^{'} & \to aG_{n+3}^{'}G_{n+2}^{'}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Fib-grammar"

\end_inset

Two encodings of the Fibonacci numbers 
\begin_inset Formula $f_{n}$
\end_inset

, where 
\begin_inset Formula $\norm{F_{n}}=\norm{G_{n}}=f_{n}$
\end_inset

 and 
\begin_inset Formula $\norm{F_{n}^{'}}=\norm{G_{n}^{'}}=f_{n}-1$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $F_{n}$
\end_inset

 and 
\begin_inset Formula $G_{n}$
\end_inset

 describe the language 
\begin_inset Formula $a^{f_{n}}$
\end_inset

, where 
\begin_inset Formula $f_{n}$
\end_inset

 is the 
\begin_inset Formula $n$
\end_inset

-th Fibonacci number.
\end_layout

\begin_layout Enumerate
AB grammar in 2NF (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:AB-grammar-2NF"

\end_inset

): 
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
A & \to a & A & \to a\\
B & \to b & B & \to b\\
A_{B,0} & \rightarrow aB & B_{A,0} & \to bA\\
A_{B,n+1} & \to aB_{B,n+1} & B_{A,n+1} & \to bA_{A,n+1}\\
B_{B,n+1} & \to bA_{B,n}A_{B,n} & A_{A,n+1} & \to aB_{A,n}B_{A,n}\\
F_{n} & \to aBA_{B,n} & G_{n} & \to aB_{A,n}B
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:AB-grammar-2NF"

\end_inset


\begin_inset Formula $F_{n}\equiv G_{n}$
\end_inset

.
 
\begin_inset Formula $\norm{F_{n}}=\norm{G_{n}}=2^{n+2}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $F_{n}$
\end_inset

 and 
\begin_inset Formula $G_{n}$
\end_inset

 describe the language 
\begin_inset Formula $\left(ab\right)^{2^{n+1}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
AB grammar in 3NF without branching (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:AB-grammar-non2NF"

\end_inset

): 
\begin_inset Formula $F_{n}$
\end_inset

 and 
\begin_inset Formula $G_{n}$
\end_inset

 describe the language 
\begin_inset Formula $\left(ab\right)^{2^{n+1}}$
\end_inset

, such as the grammar before, but this grammar is not in 2NF.
\end_layout

\begin_layout Enumerate
AB grammar in 3NF with branching (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:AB-grammar-non2NF-br"

\end_inset

): 
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\begin{aligned}A & \to a+b & A & \to a+b\\
B & \to b+a & B & \to b+a\\
A_{B,0} & \to\left(a+b\right)B & B_{A,0} & \to\left(b+a\right)A\\
A_{B,n+1} & \to\left(a+b\right)BA_{B,n}A_{B,n} & B_{A,n+1} & \to\left(b+a\right)AB_{A,n}B_{A,n}\\
F_{n} & \to\left(a+b\right)BA_{B,n} & G_{n} & \to\left(a+b\right)B_{A,n}B
\end{aligned}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:AB-grammar-non2NF-br"

\end_inset


\begin_inset Formula $F_{n}\equiv G_{n}$
\end_inset

.
 
\begin_inset Formula $\norm{F_{n}}=\norm{G_{n}}=2^{n+2}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $F_{n}$
\end_inset

 and 
\begin_inset Formula $G_{n}$
\end_inset

 describe the language 
\begin_inset Formula $\left(a+b\right)^{2^{n+2}}$
\end_inset

.
\end_layout

\begin_layout Standard
We devised all the examples ourselves.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Further explain examples?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
To measure the size of a proof, we considered two factors:
\end_layout

\begin_layout Enumerate
the total number of proof rules, and
\end_layout

\begin_layout Enumerate
the cumulative size of all conclusion polynomials, i.e.
 
\begin_inset Formula $\sum_{r\in\mathcal{R}}\size{\Concl r}.$
\end_inset


\end_layout

\begin_layout Standard
It is interesting to consider both of these factors, as we might e.g.
 have a linear number of proof rules on the one hand, however at the same
 time containing polynomials of cubic size on the other hand.
\end_layout

\begin_layout Standard
We fitted our data, both proof rules and polynomial sizes, with the following
 functions as needed:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
poly(x) & =p_{1}+p_{2}x+p_{3}x^{2}+p_{4}x^{3},\\
exp(x) & =e_{1}+e_{2}\left(e_{3}\right)^{x}+e_{4}x^{2}.
\end{align*}

\end_inset

In the graphs, the data points 
\begin_inset Quotes eld
\end_inset

Base
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Decomp.
\begin_inset Quotes erd
\end_inset

 signify the measured proof sizes for the respective tactics, while the
 dotted lines 
\begin_inset Quotes eld
\end_inset

BF
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

DF
\begin_inset Quotes erd
\end_inset

 signify the fitted functions for each tactic.
\end_layout

\begin_layout Standard
Now for the results, summarised in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Results"

\end_inset

: 
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grammar/Tactic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Base
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decomposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Results"

\end_inset

Results for the five benchmark grammars.
 P means polynomial- and E means exponential-size proofs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $2^{n}$
\end_inset

 grammar: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand include
filename "proof_sizes0.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\begin_inset Formula $2^{n}$
\end_inset

 grammar.
\end_layout

\end_inset


\end_layout

\end_inset

For this grammar, both base and decomposition tactic seem to produce polynomial-
size proofs.
 Interestingly, the base produces more rules with less symbols overall.
\end_layout

\begin_layout Enumerate
Fibonacci grammar: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand include
filename "proof_sizes1.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for Fibonacci grammar.
\end_layout

\end_inset


\end_layout

\end_inset

Here we see that the base produces exponential-size proofs, both for rules
 and symbols, while decomposition stays polynomial.
\end_layout

\begin_layout Enumerate
AB grammar in 2NF: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand include
filename "proof_sizes2.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for AB grammar in 2NF.
\end_layout

\end_inset


\end_layout

\end_inset

Both tactics seem to produce polynomial-size proofs, with the base outperforming
 the decomposition with apparently linear proof sizes.
\end_layout

\begin_layout Enumerate
AB grammar without branching: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand include
filename "proof_sizes3.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for AB grammar without branching.
\end_layout

\end_inset


\end_layout

\end_inset

Again, here the base produces an exponential-size proof (as expected with
 the result from lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:Base-replacement-exp"

\end_inset

), while the decomposition remains polynomial.
\end_layout

\begin_layout Enumerate
AB grammar with branching: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand include
filename "proof_sizes4.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for AB grammar with branching.
\end_layout

\end_inset


\end_layout

\end_inset

As all production rules for this grammar are (strict) sums, we cannot apply
 decomposition here, so the decomposition tactic will always fall back to
 the base tactic.
 As the latter produces exponential-size proofs, the decomposition also
 produces exponential-size proofs.
\end_layout

\begin_layout Chapter
Conclusion
\begin_inset CommandInset label
LatexCommand label
name "chap:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
We studied several existing algorithms to decide equivalence of simple determini
stic grammars, and created several different algorithms based on them to
 produce equivalence proofs in our own proof system.
 Unfortunately, it turned out that all our algorithms have a complexity
 of 2-EXPTIME, which is far away from our projected goal of PTIME.
 Nonetheless, in our experiments our decomposition tactic always seemed
 to yield polynomial-size proofs for the special case of compression grammars,
 so at least for a subclass of SDGs, we do not have any counterexample yet
 of a grammar evoking exponential-size proofs.
\end_layout

\begin_layout Standard
The problem has been difficult to treat as we could not find a way to translate
 several techniques from the existing PTIME algorithms into proofs in our
 proof system; however, this might be possible in the future by adding new
 proof rules to the proof system, making it more powerful and therefore
 accommodating the function of the PTIME algorithms.
\end_layout

\begin_layout Standard
A completely different approach to the problem would be to use a different
 proof system to express the executions of existing PTIME algorithms as
 proofs.
 This approach would have the advantage of yielding polynomial-size proofs
 for sure.
 However, the proof system would be quite complex, while our original goal
 was to find out if polynomial-size proofs could be constructed with a relativel
y simple proof system like ours.
\end_layout

\begin_layout Standard
Another approach would be to formally prove the correctness of a PTIME algorithm
, using a proof assistant like Coq 
\begin_inset CommandInset citation
LatexCommand cite
key "bertot2004"

\end_inset

 or Isabelle 
\begin_inset CommandInset citation
LatexCommand cite
key "paulson1990"

\end_inset

 to verify the proof afterwards.
 These programs can also automatically produce code from such a proof afterwards
, meaning we can obtain a program formally proved for correctness.
 However, currently the compilation of the resulting code may still introduce
 errors into the program, or the machine running the program might misbehave,
 producing a wrong result without us being able to verify it.
\end_layout

\begin_layout Standard
One last, but for us rather important aspect of this work is the creation
 of several original SDGs yielding exponential-size words, with non-trivially
 equivalent variables, which is something we did not find so far in existing
 literature.
 May they serve as inspiration for those who walk this rocky road well after
 us.
\end_layout

\begin_layout Chapter
Appendix: Soundness and completeness
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix"

\end_inset


\end_layout

\begin_layout Standard
Here we prove that our proof strategy using the first proof tactic as shown
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Proof-strategy-1"

\end_inset

 is sound and complete.
 To show soundness, we have to verify that the conditions in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Goal-proved"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Unique-conclusions"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Premises-proved"

\end_inset

 are met.
 To show completeness, we have to assure that each construction rule preserves
 truth when going from conclusion to the premises, and that each proof construct
ion terminates.
\end_layout

\begin_layout Section
Soundness
\begin_inset Note Note
status open

\begin_layout Plain Layout
rest in appendix
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As our proof construction algorithm takes care of the conditions in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Goal-proved"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Unique-conclusions"

\end_inset

, we only have to verify at this point whether 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Premises-proved"

\end_inset

 is met.
 Informally, that means we have to make sure that in any proof tree constructed
 by our rules, all paths between equivalent judgements have to pass at least
 once a 
\begin_inset Formula $\times$
\end_inset

 rule.
\end_layout

\begin_layout Standard
First, we develop the proof rules until we encounter a judgement where we
 cannot determine a unique rule in advance, and describe which rules might
 be applicable at that point:
\end_layout

\begin_layout Itemize
pp:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\unaryinf{\axiomc{}}A{\Gr A}{\text{gr (Gr)}}}{\unaryinf{\axiomc{\dots}}{\Gr A}B{\text{sym (sSp)}}}AB{\text{trans (pp)}}}
\]

\end_inset

We have to consider only sSp as subsequent non-strict rule.
\end_layout

\begin_layout Itemize
pP-G:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\unaryinf{\axiomc{}}A{\Gr A}{\text{gr (Gr)}}}{\unaryinf{\axiomc{\dots}}{\Gr A}{\prod B_{y}}{\text{sym (sSP)}}}A{\prod B_{y}}{\text{trans (pP-G)}}}
\]

\end_inset

We consider sSP.
\end_layout

\begin_layout Itemize
pP-B:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}A{B_{1}\left[A\right]_{\norm{B_{1}}}}{\text{trans (pP-G)}}}{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{B_{1}\left[A\right]_{\norm{B_{1}}}}{\prod B_{y}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}A{\prod B_{y}}{\text{trans (pP-B)}}}
\]

\end_inset

We have to consider pP-G as subsequent rule.
\end_layout

\begin_layout Itemize
psS: 
\begin_inset Formula 
\[
\bussproof{\binaryinf{\unaryinf{\axiomc{}}A{\Gr A}{\text{gr (Gr)}}}{\axiom{\Gr A}{\sum_{y=1}^{n_{B}\geq1}b_{y}Q_{y}}}A{\sum_{y=1}^{n_{B}\geq1}b_{y}Q_{y}}{\text{trans (psS)}}}
\]

\end_inset

When we have to prove 
\begin_inset Formula $\Gr A\equiv\sum_{y=1}^{n_{B}\geq1}b_{y}Q_{y}$
\end_inset

, we either have to apply ss-
\begin_inset Formula $\times$
\end_inset

 or SS-
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Itemize
Pp:
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom B{\prod A_{x}}}{\prod A_{x}}B{\text{sym (Pp)}}}
\]

\end_inset

To prove 
\begin_inset Formula $B\equiv\prod A_{x}$
\end_inset

, we have to consider pP-G and pP-B.
\end_layout

\begin_layout Itemize
PP-D:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{\prod A_{x}}{D\prod_{x=2}^{n_{A}}A_{x}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{D\prod_{x=2}^{n_{A}}A_{x}}{\prod B_{y}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}{\prod A_{x}}{\prod B_{y}}{\text{trans (PP-D)}}}
\]

\end_inset

Because of 
\begin_inset Formula $\norm D=\norm{A_{1}}$
\end_inset

 and 
\begin_inset Formula $D=B_{1}\dots$
\end_inset

, the applications of PP-
\begin_inset Formula $\times$
\end_inset

 are justified.
\end_layout

\begin_layout Itemize
PP-B: 
\begin_inset Formula 
\[
\bussproof{\binaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{\prod A_{x}}{B_{1}\left[A_{1}\right]_{\norm{B_{1}}}\prod_{x=2}^{n_{A}}A_{x}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{B_{1}\left[A_{1}\right]_{\norm{B_{1}}}\prod_{x=2}^{n_{A}}A_{x}}{\prod B_{y}}{\ensuremath{\times}\text{ (PP-\ensuremath{\times})}}}{\prod A_{x}}{\prod B_{y}}{\text{trans (PP-B)}}}
\]

\end_inset

Because of 
\begin_inset Formula $\norm{B_{1}\left[A_{1}\right]_{\norm{B_{1}}}}=\norm{A_{1}}$
\end_inset

, the left application of PP-
\begin_inset Formula $\times$
\end_inset

 is justified.
 The right application of PP-
\begin_inset Formula $\times$
\end_inset

 is obvious.
\end_layout

\begin_layout Itemize
Ps-V:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiom{\prod A_{x}}{V_{b}Q}}{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{V_{b}Q}{bQ}{\ensuremath{\times}\text{ (Ps-\ensuremath{\times})}}}{\prod A_{x}}{bQ}{\text{trans (Ps-V)}}}
\]

\end_inset

To prove 
\begin_inset Formula $\prod A_{x}\equiv V_{b}Q$
\end_inset

, we have to apply PP-D or PP-B.
\end_layout

\begin_layout Itemize
PS-G:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{\prod A_{x}}{\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}}{\ensuremath{\times}\text{ (PS-\ensuremath{\times})}}}{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}}{\sum b_{y}B_{y}}{\ensuremath{+}\mbox{\text{ (SS-\ensuremath{+})}}}}{\prod A_{x}}{\sum b_{y}B_{y}}{\text{trans (PS-G)}}}
\]

\end_inset


\end_layout

\begin_layout Itemize
sSp: 
\begin_inset Formula 
\[
\bussproof{\unaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}B{\sum a_{x}A_{x}}{\text{trans (psS)}}}{\sum_{x=1}^{n_{A}\geq1}a_{x}A_{x}}B{\text{sym (sSp)}}}
\]

\end_inset

We have to consider psS.
\end_layout

\begin_layout Itemize
sSP:
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom Q{\sum a_{x}A_{x}}}{\sum_{x=1}^{n_{A}\geq1}a_{x}A_{x}}Q{\text{sym (sSp)}}}
\]

\end_inset

To prove 
\begin_inset Formula $Q\equiv\sum_{x=1}^{n_{A}\geq1}a_{x}A_{x}$
\end_inset

, we have to distinguish the cases where we have a sum of a single (
\begin_inset Formula $n_{A}=1$
\end_inset

) or of multiple (
\begin_inset Formula $n_{A}>1$
\end_inset

) elements: If we have a sum of a single element, we have the choice between
 applying Ps-
\begin_inset Formula $\times$
\end_inset

 and Ps-V; if we have a sum of multiple elements, we may apply PS-
\begin_inset Formula $\times$
\end_inset

 or PS-G.
 The cases for Ps-
\begin_inset Formula $\times$
\end_inset

 and PS-
\begin_inset Formula $\times$
\end_inset

 are trivial, so we only have to consider Ps-V and PS-G as subsequent rules.
\end_layout

\begin_layout Itemize
SS-
\begin_inset Formula $+$
\end_inset

:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{\vphantom{\sum_{y}^{1}}a_{1}P_{1}}{b_{i}Q_{i}}{\ensuremath{\times}\text{ (ss-\ensuremath{\times})}}}{\binaryinf{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{a_{2}P_{2}}{b_{j}Q_{j}}{\ensuremath{\times}\text{ (ss-\ensuremath{\times})}}}{\binaryinfc{\axiomc{\dots}}{\unaryinfc{\binaryinf{\axiomc{\dots}}{\axiomc{\dots}}{a_{n_{A}}P_{n_{A}}}{b_{l}Q_{l}}{\ensuremath{\times}\text{ (ss-\ensuremath{\times})}}}{\iddots}{\ensuremath{+}\mbox{\text{ (SS-\ensuremath{+})}}}}{\vphantom{P}\dots}{\ensuremath{+}\mbox{\text{ (SS-\ensuremath{+})}}}}{\sum_{x=2}^{n_{A}}a_{x}P_{x}}{\sum_{y=1}^{i-1}b_{y}Q_{y}+\sum_{y=i+1}^{n_{B}}b_{y}Q_{y}}{\ensuremath{+}\mbox{\text{ (SS-\ensuremath{+})}}}}{\sum a_{x}P_{x}}{\sum b_{y}Q_{y}}{\ensuremath{+}\mbox{\text{ (SS-\ensuremath{+})}}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

% the >=stealth parameter draws arrows for all edges, not only straight
 ones
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->, >=stealth, node distance = 1cm, auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Pp)                            {Pp};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (pP-B)  [above right = of Pp]   {pP-B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (pP-G)  [below right = of Pp]   {pP-G};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (sSP)   [right       = of pP-G] {sSP};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Ps-V)  [above right = of sSP]  {Ps-V};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (PS-G)  [below right = of sSP]  {PS-G};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (PP-D)  [above right = of Ps-V] {PP-D};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (PP-B)  [below right = of Ps-V] {PP-B};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (PP-S)  [below right = of PP-D] {PP-S};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (pp)    [above       = of pP-B] {pp};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (sSp)   [right       = of pp]   {sSp};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (psS)   [right       = of sSp]  {psS};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (SS-+)  [right       = of psS]  {SS-$+$};
\end_layout

\begin_layout Plain Layout

  
\backslash
path (Pp)    edge (pP-B)
\end_layout

\begin_layout Plain Layout

                edge (pP-G)
\end_layout

\begin_layout Plain Layout

        (pP-B)  edge (pP-G)
\end_layout

\begin_layout Plain Layout

        (pP-G)  edge (sSP)
\end_layout

\begin_layout Plain Layout

        (sSP)   edge (Ps-V)
\end_layout

\begin_layout Plain Layout

                edge (PS-G)
\end_layout

\begin_layout Plain Layout

        (Ps-V)  edge (PP-D)
\end_layout

\begin_layout Plain Layout

                edge (PP-B)
\end_layout

\begin_layout Plain Layout

        (PP-S)  edge (PP-D)
\end_layout

\begin_layout Plain Layout

                edge (PP-B)
\end_layout

\begin_layout Plain Layout

        (pp)    edge (sSp)
\end_layout

\begin_layout Plain Layout

        (sSp)   edge (psS)
\end_layout

\begin_layout Plain Layout

        (psS)   edge (SS-+)
\end_layout

\begin_layout Plain Layout

        (SS-+)  edge[loop below] (SS-+);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Dependency-graph"

\end_inset

Dependency graph for non-strict proof rules.
\end_layout

\end_inset


\end_layout

\end_inset

From this rule unfolding process, we construct the rule dependency graph
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Dependency-graph"

\end_inset

: This dependency graph visualises which non-strict proof rules are candidates
 for direct consequences of other non-strict proof rules.
 For example, we see that from the Ps-V node in the graph, two outgoing
 edges to PP-D and PP-B exist: This indicates that after using the Ps-V
 rule, the only non-strict rules we might have to apply in the subsequent
 step are PP-D and PP-B.
\end_layout

\begin_layout Standard
We note that there are no circularities in this graph, except for the rule
 SS-
\begin_inset Formula $+$
\end_inset

.
 However, SS-
\begin_inset Formula $+$
\end_inset

 can only be applied maximally 
\begin_inset Formula $k$
\end_inset

 subsequent times, where the grammar is in 
\begin_inset Formula $k$
\end_inset

-GNF.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Actually, if the proof construction algorithm is called to prove equivalence
 between two sums, then SS-
\begin_inset Formula $+$
\end_inset

 might even be executed 
\begin_inset Formula $d$
\end_inset

 subsequent times, where 
\begin_inset Formula $d$
\end_inset

 is the number of terms of the sum with fewer elements.
\end_layout

\end_inset

 This means that after a fixed number of rule applications, we always reach
 a strict rule.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:SS-+"

\end_inset

Proving 
\begin_inset Formula $\sum_{x=1}^{n_{A}>1}a_{x}P_{x}\equiv\sum_{y=1}^{n_{B}>1}b_{y}Q_{y}$
\end_inset

 requires 
\begin_inset Formula $\min\left(n_{A},n_{B}\right)-1$
\end_inset

 subsequent applications of SS-
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Proof
By induction on 
\begin_inset Formula $j=\min\left(n_{A},n_{B}\right)-1$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $j=0$
\end_inset

: 
\begin_inset Formula $\min\left(n_{A},n_{B}\right)=1$
\end_inset

, so we cannot apply the SS-
\begin_inset Formula $+$
\end_inset

 rule here at all, because it requires that 
\begin_inset Formula $n_{A}>1$
\end_inset

 and 
\begin_inset Formula $n_{B}>1$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $j^{'}=j+1$
\end_inset

: 
\begin_inset Formula $\min\left(n_{A},n_{B}\right)=j^{'}+1$
\end_inset

, and wlog 
\begin_inset Formula $n_{A}=j^{'}+1$
\end_inset

 and 
\begin_inset Formula $n_{B}\geq j^{'}+1$
\end_inset

.
 Therefore one application of SS-
\begin_inset Formula $+$
\end_inset

 yields the new judgements 
\begin_inset Formula $a_{1}P_{1}\equiv b_{i}Q_{i}$
\end_inset

 and 
\begin_inset Formula $\sum_{x=2}^{j^{'}+1}a_{x}P_{x}\equiv\sum_{y=1}^{i-1}b_{y}Q_{y}\equiv\sum_{y=i+1}^{n_{B}}b_{y}Q_{y}$
\end_inset

.
 We see that the sum on the left side consists of 
\begin_inset Formula $n_{A}^{'}=j^{'}$
\end_inset

 elements, and the sum on the right side consists of 
\begin_inset Formula $n_{B}^{'}=n_{B}-1$
\end_inset

 elements.
 As 
\begin_inset Formula $n_{B}\geq j^{'}+1$
\end_inset

, 
\begin_inset Formula $n_{B}^{'}\geq j^{'}$
\end_inset

, therefore 
\begin_inset Formula $\min\left(n_{A}^{'},n_{B}^{'}\right)=j^{'}$
\end_inset

.
 By induction, the new sum requires 
\begin_inset Formula $\min\left(n_{A}^{'},n_{B}^{'}\right)-1=j^{'}-1=j$
\end_inset

 subsequent applications of SS-
\begin_inset Formula $+$
\end_inset

.
 Together with the first SS-
\begin_inset Formula $+$
\end_inset

 application, that makes 
\begin_inset Formula $j+1=j'$
\end_inset

 SS-
\begin_inset Formula $+$
\end_inset

 applications, which concludes the proof.
\end_layout

\end_deeper
\begin_layout Standard
We now have to make sure that all judgements generated by a sequential applicati
on of our proof rules are different, at least until we apply a 
\begin_inset Formula $\times$
\end_inset

 rule.
\begin_inset Note Note
status open

\begin_layout Plain Layout
How shall we actually show this?
\end_layout

\end_inset

 For example, for the sSP rule, we have to make sure that for the proof
 paths
\end_layout

\begin_layout Itemize
sSP 
\begin_inset Formula $\to$
\end_inset

 Ps-V 
\begin_inset Formula $\to$
\end_inset

 PP-D,
\end_layout

\begin_layout Itemize
sSP 
\begin_inset Formula $\to$
\end_inset

 Ps-V 
\begin_inset Formula $\to$
\end_inset

 PP-B, and
\end_layout

\begin_layout Itemize
sSP 
\begin_inset Formula $\to$
\end_inset

 PS-G,
\end_layout

\begin_layout Standard
for each path all judgements on that path have to be non-equivalent.
\end_layout

\begin_layout Standard
This is not a trivial property; for instance, consider the initial version
 PS-
\begin_inset Formula $\bigcirc$
\end_inset

 of the PS-G proof rule which we used during the conception of the proof
 rules:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiom{\prod A_{x}}{\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}}}{\axiom{\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}}{\sum b_{y}B_{y}}}{\prod A_{x}}{\sum b_{y}B_{y}}{\text{trans (PS-\bigcirc)}}}
\]

\end_inset

The only difference between PS-
\begin_inset Formula $\bigcirc$
\end_inset

 and the final PS-G rule is that PS-
\begin_inset Formula $\bigcirc$
\end_inset

 lacks the condition 
\begin_inset Formula $\sum b_{y}B_{y}\neq\Gr{A_{1}}\cdot\prod_{x=2}^{n_{A}}A_{x}$
\end_inset

 from PS-G.
 With the PS-
\begin_inset Formula $\bigcirc$
\end_inset

 rule, we might construct a proof as follows, where 
\begin_inset Formula $A\to a_{1}+a_{2}$
\end_inset

:
\begin_inset Formula 
\[
\bussproof{\binaryinf{\axiom{AB}{a_{1}B+a_{2}B}}{\axiom{a_{1}B+a_{2}B}{a_{1}B+a_{2}B}}{AB}{a_{1}B+a_{2}B}{\text{trans (PS-\ensuremath{\bigcirc})}}}
\]

\end_inset

However, this violates the condition in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Premises-proved"

\end_inset

, as 
\begin_inset Formula $AB\equiv a_{1}B+a_{2}B$
\end_inset

 appears in the conclusion as well as in a premise of the same non-strict
 rule.
\end_layout

\begin_layout Standard
Even if a proof rule locally satisfies 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:Premises-proved"

\end_inset

, meaning that all its premises are different from its conclusions, we still
 might have situations where sequential applications of proof rules produce
 incorrect results.
 For example, if we had a proof rule
\begin_inset Formula 
\[
\bussproof{\unaryinf{\axiom{\sum b_{y}Q_{y}}{\sum a_{x}P_{x}}}{\sum a_{x}P_{x}}{\sum b_{y}Q_{y}}{\text{sym (SS-\ensuremath{\bigcirc})}}},
\]

\end_inset

then it might produce a proof as follows:
\begin_inset Formula 
\[
\bussproof{\unaryinf{\unaryinf{\axiom{a+b}{c+d}}{c+d}{a+b}{\text{sym (SS-\ensuremath{\bigcirc})}}}{a+b}{c+d}{\text{sym (SS-\ensuremath{\bigcirc})}}}.
\]

\end_inset

This is an invalid proof as well, as there is no single application of 
\begin_inset Formula $\times$
\end_inset

 between the top and bottom judgement 
\begin_inset Formula $a+b\equiv c+d$
\end_inset

.
\end_layout

\begin_layout Standard
We manually verified that our proof tactics do not produce invalid circularities
, but due to the length of the proof, we omit it here.
\end_layout

\begin_layout Section
Completeness
\begin_inset Note Note
status open

\begin_layout Plain Layout
move to main
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we show completeness of our proof strategy.
 For this, we first define an auxiliary construction, which we baptised
 
\emph on
cluster
\emph default
.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Cluster
\end_layout

\end_inset

Given a proof of 
\begin_inset Formula $p_{1}\equiv p_{2}$
\end_inset

 realised by proof rules 
\begin_inset Formula $\mathcal{R}$
\end_inset

, a 
\emph on
cluster
\emph default
 
\begin_inset Formula $C\subseteq\mathcal{R}$
\end_inset

 is a set of proof rules, where we call the set of 
\begin_inset Formula $\times$
\end_inset

-rules in 
\begin_inset Formula $C$
\end_inset

 
\emph on
leaves
\emph default
.
 The following conditions define a cluster:
\end_layout

\begin_deeper
\begin_layout Itemize
A cluster has exactly one root rule 
\begin_inset Formula $r$
\end_inset

, whose conclusion must be 
\begin_inset Formula $p_{1}\equiv p_{2}$
\end_inset

 or equivalent to a premise of a 
\begin_inset Formula $\times$
\end_inset

 rule not in 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Itemize
For each rule in 
\begin_inset Formula $C$
\end_inset

 except for 
\begin_inset Formula $r$
\end_inset

, its conclusion must be equal to some premise of another rule in 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Itemize
For each non-leaf in 
\begin_inset Formula $C$
\end_inset

, its premise must be equal to the conclusion of another rule in 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Itemize
For each leaf in 
\begin_inset Formula $C$
\end_inset

, there must not exist any rule in 
\begin_inset Formula $C$
\end_inset

 whose conclusion is equal to any premise of the leaf.
\end_layout

\end_deeper
\begin_layout Definition
Given a cluster 
\begin_inset Formula $C$
\end_inset

, we define a child cluster of 
\begin_inset Formula $C$
\end_inset

 to be a cluster whose root node has a conclusion equal to a premise of
 a leaf of 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Standard
We illustrate clusters in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Clusters"

\end_inset

: 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
svgwidth{250pt}
\end_layout

\begin_layout Plain Layout


\backslash
includesvg{Cluster}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Clusters"

\end_inset

Illustration of clusters.
\end_layout

\end_inset


\end_layout

\end_inset

There we see a cluster 
\begin_inset Formula $C$
\end_inset

, containing several proof rules at the junctions of its proof tree.
 It contains two 
\begin_inset Formula $\times$
\end_inset

 rules, which are its leaves, and whose premises are the conclusions of
 the root rules of its child clusters.
\end_layout

\begin_layout Lemma
From each proof 
\begin_inset Formula $\mathcal{R}$
\end_inset

 of 
\begin_inset Formula $j$
\end_inset

, we can construct a set of clusters such that each proof rule in 
\begin_inset Formula $\mathcal{R}$
\end_inset

 is also contained in at least one cluster.
\end_layout

\begin_layout Proof
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO.
\end_layout

\end_inset

First, let 
\begin_inset Formula 
\[
\mathcal{R}_{\times}:=\left\{ r\mid r\in\mathcal{R}\land\exists r':\, r'=\bussproof{\binaryinfc{\axiomc{P_{1}}}{\axiomc{P_{2}}}C{\ensuremath{\times}}}\land\Concl r\in\Prem{\left\{ P_{1}\right\} \cup\left\{ P_{2}\right\} }\right\} 
\]

\end_inset

the set of rules whose conclusions are contained in premises of 
\begin_inset Formula $\times$
\end_inset

 rules.
 Then, let
\begin_inset Formula 
\[
\mathrm{Prem}_{\mathcal{R},\times}:=\bigcup_{r\in\mathcal{R}_{\times}}\PremR r
\]

\end_inset

the set of rules whose conclusions appear in at least one premise of at
 least one rule in 
\begin_inset Formula $\mathcal{R}_{\times}$
\end_inset

.
\end_layout

\begin_layout Proof
With this machinery in place, we finally define
\begin_inset Formula 
\[
\mathrm{Cluster}\left(r\right):=\begin{cases}
r & r=\bussproof{\binaryinfc{\axiomc{P_{1}}}{\axiomc{P_{2}}}C{\ensuremath{\times}}};\\
r\cup\bigcup_{r_{p}\in\PremR r}\mathrm{Cluster}\left(r_{p}\right) & \mathrm{else}.
\end{cases}
\]

\end_inset

 to obtain a cluster given a root rule 
\begin_inset Formula $r$
\end_inset

.
 This function is similar to 
\begin_inset Formula $\Premstartimes r$
\end_inset

, with the difference that 
\begin_inset Formula $\Premstartimes r$
\end_inset

 returns all rules up to 
\begin_inset Formula $\times$
\end_inset

 rules (excluding them), while 
\begin_inset Formula $\mathrm{Cluster}\left(r\right)$
\end_inset

 returns also the 
\begin_inset Formula $\times$
\end_inset

 rules at the top, which represent the leafs of the cluster.
\end_layout

\begin_layout Proof
Now let 
\begin_inset Formula $r_{j}\in\mathcal{R}$
\end_inset

 denote the rule which has 
\begin_inset Formula $j$
\end_inset

 as conclusion.
 Then we can find the set of clusters with
\begin_inset Formula 
\[
\mathrm{Clusters}\left(\mathcal{R}\right):=\bigcup_{r\in\left(\mathrm{Prem}_{\mathcal{R},\times}\cup r_{j}\right)}\mathrm{Cluster}\left(r\right).
\]

\end_inset


\end_layout

\begin_layout Lemma
For each cluster 
\begin_inset Formula $C$
\end_inset

, the number of rules in the cluster is bounded by 
\begin_inset Formula $2^{h+1}$
\end_inset

 and the number of leafs is bounded by 
\begin_inset Formula $2^{h}$
\end_inset

, with 
\begin_inset Formula $h$
\end_inset

 being linear in 
\begin_inset Formula $k$
\end_inset

, where the grammar is in 
\begin_inset Formula $k$
\end_inset

-GNF.
\end_layout

\begin_layout Proof
We can represent each cluster as a tree, and we can also find a bound 
\begin_inset Formula $h$
\end_inset

 for the height of the tree, which is:
\begin_inset Formula 
\[
h=\max_{r\in\mathcal{R}}\left(\Heightstartimes r\right),
\]

\end_inset


\begin_inset Formula 
\[
\Heightstartimes r:=\begin{cases}
1 & r=\bussproof{\binaryinfc{\axiomc{P_{1}}}{\axiomc{P_{2}}}C{\ensuremath{\times}}};\\
1+\max_{r_{p}\in\PremR r}\left(\Heightstartimes{r_{p}}\right) & \mathrm{else}.
\end{cases}
\]

\end_inset

The fact that 
\begin_inset Formula $h$
\end_inset

 is linear in 
\begin_inset Formula $k$
\end_inset

 follows from lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:SS-+"

\end_inset

.
\end_layout

\begin_layout Proof
As each proof rule has maximally two premises, we calculate the maximum
 number of rules in a cluster to be 
\begin_inset Formula $2^{h+1}$
\end_inset

, and the maximal number of 
\begin_inset Formula $\times$
\end_inset

 rules (which, by definition, can only appear in the leaves of the cluster
 tree) in the cluster equals 
\begin_inset Formula $2^{h}$
\end_inset

.
\end_layout

\begin_layout Theorem
The number of clusters is bounded by 
\begin_inset Formula $\left(2^{h}\right)^{\left(k+1\right)^{n}}$
\end_inset

.
\end_layout

\begin_layout Proof
As each cluster may produce maximally 
\begin_inset Formula $2^{h}$
\end_inset

 new judgements to prove, and these judgements will have a strictly smaller
 norm than the conclusion of the root node of the cluster due to being premises
 of 
\begin_inset Formula $\times$
\end_inset

 rules, we obtain a tree of clusters of maximal height 
\begin_inset Formula $n_{m}$
\end_inset

, where 
\begin_inset Formula $n_{m}$
\end_inset

 is the maximal norm possible.
 As 
\begin_inset Formula $n_{m}\leq\left(k+1\right)^{n}$
\end_inset

, we have the final maximal number of clusters 
\begin_inset Formula $\left(2^{h}\right)^{\left(k+1\right)^{n}}$
\end_inset

.
\end_layout

\begin_layout Lemma
The number of symbols in a judgement is bounded by 
\begin_inset Formula $k\cdot\left(k+1\right)^{n}$
\end_inset

.
\end_layout

\begin_layout Proof
In a 
\begin_inset Formula $k$
\end_inset

-GNF, there appear sums of maximally 
\begin_inset Formula $k$
\end_inset

 addends, which have a maximal length of the longest norm, which is bounded
 by 
\begin_inset Formula $\left(k+1\right)^{n}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "th:Proof-EXP"

\end_inset

For two simple polynomials 
\begin_inset Formula $p_{1},p_{2}\in\mathcal{P}$
\end_inset

 with 
\begin_inset Formula $\lang{p_{1}}=\lang{p_{2}}$
\end_inset

, we can construct a valid proof of 
\begin_inset Formula $p_{1}\equiv p_{2}$
\end_inset

 not containing 
\begin_inset Formula $\bot$
\end_inset

 in 2-EXPSPACE.
\end_layout

\begin_layout Proof
As each cluster contains maximally 
\begin_inset Formula $2^{h+1}$
\end_inset

 rules, we have the maximal number of rules
\begin_inset Formula 
\[
2^{h+1}\cdot\left(2^{h}\right)^{\left(k+1\right)^{n}}.
\]

\end_inset


\end_layout

\begin_layout Remark*
Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "th:Proof-EXP"

\end_inset

 does in general not hold for non-simple polynomials.
 If it would, then we could always obtain a valid polynomial 
\begin_inset Formula $p_{1}+p_{2}$
\end_inset

 from 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 (which is not always possible for simple polynomials) and decide whether
 
\begin_inset Formula $\lang{p_{1}+p_{2}}=\lang{p_{2}}$
\end_inset

.
 However, this would be equivalent to deciding whether 
\begin_inset Formula $\lang{p_{1}}\subseteq\lang{p_{2}}$
\end_inset

, which has been proven by Friedman in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedman1976"

\end_inset

 to be undecidable.
\end_layout

\begin_layout Theorem
The proof system in definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:Proof-definition"

\end_inset

 is complete.
\end_layout

\begin_layout Proof
Is a direct consequence of theorem 
\begin_inset CommandInset ref
LatexCommand formatted
reference "th:Proof-EXP"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "Literature"
options "abbrv"

\end_inset


\end_layout

\end_body
\end_document
