#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass clseminar
\begin_preamble
\usepackage{color}
\usepackage{graphicx}
% import graphic files from other directories
\usepackage{import}
\usepackage{Isabelle/output/document/isabelle}
\usepackage{Isabelle/output/document/isabellesym}
\usepackage{listings}
\usepackage[svgpath=Graphics/]{svg}

% to show DRAFT watermark
\usepackage[firstpage]{draftwatermark}

% center figures in all float environments
\makeatletter
\g@addto@macro\@floatboxreset{\centering}
\makeatother
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Calculating norms of simple deterministic grammars
\end_layout

\begin_layout Author
Michael FÃ¤rber
\end_layout

\begin_layout Supervisor
Cezary Kaliszyk
\end_layout

\begin_layout Abstract
For normed simple deterministic grammars, there exist algorithms in PTIME
 to calculate the length of the shortest word (norm) of each variable.
 We implement and verify such an algorithm in Isabelle/HOL.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
Why is the norm of SDG interesting?
\end_layout

\begin_layout Subsection
Isabelle
\end_layout

\begin_layout Standard
Isabelle is an interactive theorem prover programmed in Standard ML.
 It provides a meta-logic to formalise a multitude of different object logics,
 such as ZF (Zermelo-Fraenkel Set Theory), CTT (Constructive Type Theory),
 FOL (First Order Logic).
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includesvg[width=0.6
\backslash
columnwidth]{Logics}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Logics.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert image of logics in Isabelle!
\end_layout

\end_inset

 The most mature object logic in Isabelle at the time of writing is HOL
 (Higher Order Logic), which provides a comfortable programming environment
 similar to common functional programming languages, providing many auxiliary
 functions for e.g.
 list operations, along with lemmata about these operations.
\end_layout

\begin_layout Standard
Isabelle/HOL also permits the export of code written in it into other languages,
 such as Scala, OCaml and Haskell.
 Having proven certain properties of functions in Isabelle, we can then
 use the exported functions in aforementioned languages, trusting they also
 behave according to our proved behaviour.
\begin_inset Foot
status open

\begin_layout Plain Layout
Of course, we can not exclude the possibility of a faulty target language
 compiler or hardware failures, but even with these restrictions, we can
 be a lot more confident in the function of our verified program compared
 to a completely unverified alternative.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SDG
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert part from master's thesis here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
explain SDG, norms
\end_layout

\begin_layout Standard
Example of SDG 
\end_layout

\begin_layout Section
Norm formalisation
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "IsaTeX/Norm_defs.tex"

\end_inset


\end_layout

\begin_layout Section
General-purpose parts
\end_layout

\begin_layout Subsection
alist
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "IsaTeX/AList_ext.tex"

\end_inset


\end_layout

\begin_layout Subsection
partition_iterate
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "IsaTeX/Partition_iterate.tex"

\end_inset


\end_layout

\begin_layout Standard
(topological ordering; example application: SAT of > Horn clauses) 
\end_layout

\begin_layout Section
Norm calculation algorithm
\end_layout

\begin_layout Standard
In the original OCaml program to construct equivalence proofs, the user
 had to provide an order 
\begin_inset Formula $\preceq$
\end_inset

 with the grammar, meaning that for all variables 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 of the grammar, if 
\begin_inset Formula $X\preceq Y$
\end_inset

, then 
\begin_inset Formula $\left\Vert X\right\Vert \leq\left\Vert Y\right\Vert $
\end_inset

.
 In the implementation, this was solved by providing the variables in a
 list, and this list had to be sorted by ascending norm.
 That way, we could ignore production rules with variables not having appeared
 before in the list, because their norm would by definition be greater or
 equal to the norm of the current variable and could therefore not induce
 the norm for the current variable.
 In case that the norm of a variable was calculated to be smaller than the
 norm of a variable at an earlier position in the list, the norm calculation
 quit with an error.
\end_layout

\begin_layout Standard
While this was a reliable and fast method to calculate norms, this method
 had the disadvantage that the user had to construct a variable order when
 formulating the grammar, and formalising variable orders would have imposed
 an unnatural and in principle unnecessary restriction on grammars.
 For this reason, we looked into different approaches to generate the norm:
 One was to identify variables 
\begin_inset Formula $V_{\infty}$
\end_inset

 with an infinite norm, remove them from the grammar, then also remove all
 production rules containing elements of 
\begin_inset Formula $V_{\infty}$
\end_inset

 from the grammar.
 But how to find all variables with infinite norm? Consider the following
 example:
\begin_inset Formula 
\begin{align*}
X & \to aY\\
Y & \to aZ\\
Z & \to aX
\end{align*}

\end_inset

As we can see, none of these variables has a finite norm, but to find that
 out, we have to look at each of these variables.
 An easier problem is to find the set 
\begin_inset Formula $V_{n}$
\end_inset

 of all variables which have a finite norm --- having this set and knowing
 that 
\begin_inset Formula $V=V_{\infty}\cup V_{n}$
\end_inset

 with 
\begin_inset Formula $V_{\infty}\cap V_{n}=\emptyset$
\end_inset

, we can obtain 
\begin_inset Formula $V_{\infty}$
\end_inset

 from 
\begin_inset Formula $V$
\end_inset

 and 
\begin_inset Formula $V_{n}$
\end_inset

.
 So how to calculate 
\begin_inset Formula $V_{n}$
\end_inset

? We can use the following algorithm to do that, initialising 
\begin_inset Formula $V_{n}$
\end_inset

 with 
\begin_inset Formula $\emptyset$
\end_inset

:
\end_layout

\begin_layout Enumerate
Obtain all variables from grammar which have a production rule containing
 only variables in 
\begin_inset Formula $V_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
If such variables exist, remove those variables from grammar and add them
 to 
\begin_inset Formula $V_{n}$
\end_inset

, otherwise the algorithm terminates and returns 
\begin_inset Formula $V_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Go to 1.
\end_layout

\begin_layout Standard
As we can see, the amount of variables in the grammar constantly decreases,
 therefore the algorithm terminates, because we consider only grammars with
 a finite set of variables.
\end_layout

\begin_layout Standard
This algorithm therefore gives as the means to calculate 
\begin_inset Formula $V_{n}$
\end_inset

, and thus also 
\begin_inset Formula $V_{\infty}$
\end_inset

.
 Knowing this information, does it help us to calculate the norms? One thing
 that we can do now is to remove all production rules from the grammar which
 contain variables in 
\begin_inset Formula $V_{\infty}$
\end_inset

, for they will not induce any finite norm and are therefore irrelevant
 for norm calculation.
 Now the first idea might be to calculate the norm of a variable as soon
 as norms for all variables of the variable's
\begin_inset Note Note
status open

\begin_layout Plain Layout
check possessive!
\end_layout

\end_inset

 production rules have been calculated.
 We can, however, easily find a counterexample for this approach:
\begin_inset Formula 
\begin{align*}
A & \to a\\
B & \to bAA+cC\\
C & \to cAA+bB
\end{align*}

\end_inset

Here, using the approach above, we will wait for 
\begin_inset Formula $B$
\end_inset

 to be normed because 
\begin_inset Formula $C$
\end_inset

 was not normed yet, but also 
\begin_inset Formula $C$
\end_inset

 will wait for 
\begin_inset Formula $B$
\end_inset

, so we are in a deadlock.
 Therefore, we decided to calculate a norm for a variable as soon as all
 variables of 
\emph on
any
\emph default
 of the variable's production rules have a known norm.
 This, however, will not always yield the correct norm, but merely an overestima
tion of the norms --- observe:
\begin_inset Note Note
status open

\begin_layout Plain Layout
Example here, best from slides!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example, we have to choose of which variable we should calculate
 the norm first, and if we choose 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset

 instead of 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset

, then the norm of 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset

 will be too big, therefore wrong.
 However, because we overestimate norms, we can try to make the norms smaller
 after the calculation of the initial norms, thus finding a fixpoint where
 the norms to not change anymore, at which point they will be minimal and
 therefore valid.
 We can reach such a fixpoint after 
\begin_inset Formula $\mathcal{O}(n)$
\end_inset

 iterations, where 
\begin_inset Formula $n$
\end_inset

 is the number of variables.
 Consider the following example:
\begin_inset Formula 
\begin{align*}
L_{1} & \to l & E_{1} & \to e & X_{1} & \to lL_{4}+eE_{3}\\
L_{n+1} & \to lL_{n} & E_{n+1} & \to eE_{n}E_{n} & X_{n+1} & \to xX_{n}
\end{align*}

\end_inset

The construction has been chosen in such a way that 
\begin_inset Formula $L_{i}$
\end_inset

 grows linearly, while 
\begin_inset Formula $E_{i}$
\end_inset

 grows exponentially.
 If we then iteratively calculate the norms, we can calculate the norms
 of 
\begin_inset Formula $E_{3}$
\end_inset

 and 
\begin_inset Formula $L_{3}$
\end_inset

 in the same iteration.
 At that point, let us assume we calculate 
\begin_inset Formula $\left\Vert X_{1}\right\Vert $
\end_inset

 to be 
\begin_inset Formula $1+\left\Vert E_{3}\right\Vert $
\end_inset

 instead of 
\begin_inset Formula $1+\left\Vert L_{4}\right\Vert $
\end_inset

, because we have previously already calculated the norm of 
\begin_inset Formula $E_{3}$
\end_inset

, but the norm of 
\begin_inset Formula $L_{4}$
\end_inset

 is unknown yet.
 However, 
\begin_inset Formula $E_{3}$
\end_inset

 was a wrong choice, because the norm of 
\begin_inset Formula $L_{4}$
\end_inset

 will be calculated one step later to be smaller than the norm of 
\begin_inset Formula $E_{3}$
\end_inset

, but having already calculated 
\begin_inset Formula $\left\Vert X_{1}\right\Vert $
\end_inset

, this error will propagate until 
\begin_inset Formula $X_{n}$
\end_inset

.
 In every iteration of the following fixpoint calculation, however, only
 one 
\begin_inset Formula $X_{i}$
\end_inset

 will decrease, thus amounting to a total of about 
\begin_inset Formula $n$
\end_inset

 iterations.
 Because in every iteration, we look through all norms if they are correct,
 our fixpoint calculation has complexity 
\begin_inset Formula $\mathcal{O}(n^{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "IsaTeX/Norm_funs.tex"

\end_inset


\end_layout

\begin_layout Section
Proof
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "IsaTeX/Norm_proofs.tex"

\end_inset


\end_layout

\begin_layout Subsection
Proof strategy
\end_layout

\begin_layout Standard
(how did I create the proof, bottom-up vs.
 top-down)
\end_layout

\begin_layout Subsection
Statistics
\end_layout

\begin_layout Section
Integration with existing code?
\end_layout

\end_body
\end_document
