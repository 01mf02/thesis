#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass clseminar
\begin_preamble
\usepackage{color}
\usepackage{graphicx}
% import graphic files from other directories
\usepackage{import}
\usepackage{Isabelle/output/document/isabelle}
\usepackage{Isabelle/output/document/isabellesym}
\usepackage{listings}
\usepackage[svgpath=Graphics/]{svg}

% to show DRAFT watermark
\usepackage[firstpage]{draftwatermark}

% center figures in all float environments
\makeatletter
\g@addto@macro\@floatboxreset{\centering}
\makeatother

% graph drawing
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows, positioning}


\isadroptag{theory}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Calculating norms of simple deterministic grammars
\end_layout

\begin_layout Author
Michael FÃ¤rber
\end_layout

\begin_layout Supervisor
Cezary Kaliszyk
\end_layout

\begin_layout Abstract
For normed simple deterministic grammars, there exist algorithms in PTIME
 to calculate the length of the shortest word (norm) of each variable.
 We implement and verify such an algorithm in Isabelle/HOL.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "Includes.lyx"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Outline of the document structure.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
In my master's thesis, I present a way to construct and verify equivalence
 proofs of simple deterministic grammars.
 To increase the confidence in the algorithm I developed for the thesis,
 we considered verifying the algorithm formally in a theorem prover.
 The algorithm consists of many parts which could be considered worthwhile
 to verify:
\end_layout

\begin_layout Itemize
Grammar verification
\end_layout

\begin_layout Itemize
Norm calculation
\end_layout

\begin_layout Itemize
Variable base construction
\end_layout

\begin_layout Itemize
Proof construction
\end_layout

\begin_layout Itemize
Proof verification
\end_layout

\begin_layout Itemize
\begin_inset Formula $\dots$
\end_inset


\end_layout

\begin_layout Standard
It turned out that the whole algorithm was to big to be verified in the
 framework of this seminar, so we concentrated on verifying the first two
 parts, namely grammar verification and norm calculation, in Isabelle/HOL.
\end_layout

\begin_layout Subsection
Isabelle
\end_layout

\begin_layout Standard
Isabelle is an interactive theorem prover programmed in Standard ML.
 It provides a meta-logic to formalise a multitude of different object logics,
 such as ZF (Zermelo-Fraenkel Set Theory), CTT (Constructive Type Theory),
 FOL (First Order Logic) --- see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Object-logics."

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includesvg[width=0.6
\backslash
columnwidth]{Logics}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Object logics in Isabelle.
\begin_inset CommandInset label
LatexCommand label
name "fig:Object-logics."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The most mature object logic in Isabelle at the time of writing is HOL (Higher
 Order Logic), which provides a comfortable programming environment similar
 to common functional programming languages, providing many auxiliary functions
 for e.g.
 list operations, along with lemmata about these operations.
\end_layout

\begin_layout Standard
Isabelle/HOL also permits the export of code written in it into other languages,
 such as Scala, OCaml and Haskell.
\begin_inset CommandInset citation
LatexCommand cite
key "haftmann2013"

\end_inset

 Having proven certain properties of functions in Isabelle, we can then
 use the exported functions in aforementioned languages, trusting they also
 behave according to our proved behaviour.
\begin_inset Foot
status open

\begin_layout Plain Layout
Of course, we can not exclude the possibility of a faulty target language
 compiler or hardware failures, but even with these restrictions, we can
 be a lot more confident in the function of our verified program compared
 to a completely unverified alternative.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Grammars
\end_layout

\begin_layout Standard
In this section, we discuss the basics of simple deterministic grammars
 and show what their norm is.
 This part is largely based on parts of my master's thesis.
\end_layout

\begin_layout Subsection
Preliminaries
\begin_inset CommandInset label
LatexCommand label
name "chap:Preliminaries"

\end_inset


\end_layout

\begin_layout Standard
Here we define some terms we will use throughout the document.
 For a longer introduction, see the first chapters of 
\begin_inset CommandInset citation
LatexCommand cite
key "hopcroft1979,carton2008"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Alphabet
\end_layout

\end_inset

An alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 is a finite set of symbols.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Word
\end_layout

\end_inset

A word 
\begin_inset Formula $w$
\end_inset

 over an alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 is a finite sequence 
\begin_inset Formula $w_{1}w_{2}\dots w_{n}$
\end_inset

, where each 
\begin_inset Formula $w_{i}$
\end_inset

 is a symbol in 
\begin_inset Formula $\Sigma$
\end_inset

 and the length of the word 
\begin_inset Formula $\left|w\right|$
\end_inset

 is 
\begin_inset Formula $n$
\end_inset

.
 The empty word 
\begin_inset Formula $\varepsilon$
\end_inset

 is defined to be the empty sequence, with 
\begin_inset Formula $\left|\varepsilon\right|=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Language
\end_layout

\end_inset

 A language 
\begin_inset Formula $\mathcal{L}$
\end_inset

 over the alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 is a set of words over 
\begin_inset Formula $\Sigma$
\end_inset

, meaning 
\begin_inset Formula $\mathcal{L}\subset\mbox{\Sigma}^{*}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Concatenation of words
\end_layout

\end_inset

 The concatenation of two words 
\begin_inset Formula $u=u_{1}\dots u_{m}$
\end_inset

 and 
\begin_inset Formula $v=v_{1}\dots v_{n}$
\end_inset

 is the new word 
\begin_inset Formula $u\cdot v=u_{1}\dots u_{m}v_{1}\dots v_{n}$
\end_inset

.
 This operation is associative, i.e.
 
\begin_inset Formula $\left(u\cdot v\right)\cdot w=u\cdot\left(v\cdot w\right)$
\end_inset

, and the empty word 
\begin_inset Formula $\varepsilon$
\end_inset

 is its neutral element, i.e.
 
\begin_inset Formula $w\cdot\varepsilon=\varepsilon\cdot w=w$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Product of languages
\end_layout

\end_inset

 The product of two languages 
\begin_inset Formula $\mathcal{L}_{1},\,\mathcal{L}_{2}$
\end_inset

 is defined to be 
\begin_inset Formula 
\[
\mathcal{L}_{1}\cdot\mathcal{L}_{2}:=\bigcup_{\left\{ \left(x,y\right)\mid x\in\mathcal{L}_{1},\, y\in\mathcal{L}_{2}\right\} }x\cdot y.
\]

\end_inset


\end_layout

\begin_layout Subsection
Context-free grammars
\end_layout

\begin_layout Definition
A context-free grammar (CFG) is a triple 
\begin_inset Formula $(V,T,P)$
\end_inset

 such that
\end_layout

\begin_layout Itemize
\begin_inset Formula $V$
\end_inset

 is a finite set of variables,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $T$
\end_inset

 is a finite set of terminals,
\end_layout

\begin_layout Itemize
\begin_inset Formula $P\subset V\times(V\cup T)^{*}$
\end_inset

 is a finite set of production rules.
 For each variable 
\begin_inset Formula $X\in V$
\end_inset

, there exists at least one production rule 
\begin_inset Formula $(X,\alpha)\in P$
\end_inset

, i.e.
\begin_inset Formula 
\[
\forall X\in V,\,\exists\alpha\in\left(V\cup T\right)^{*}:\,(X,\alpha)\in P.
\]

\end_inset

To express all production rules for a variable 
\begin_inset Formula $X\in V$
\end_inset

, we write
\begin_inset Formula 
\[
X\to\sum_{\left(X,\alpha\right)\in P}\alpha.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we define the different types of words.
\end_layout

\begin_layout Definition
A variable word denotes a finite sequence of variables 
\begin_inset Formula $w_{V}\in V^{*}$
\end_inset

, and a terminal word denotes a finite sequence of terminals 
\begin_inset Formula $w_{T}\in T^{*}$
\end_inset

.
\end_layout

\begin_layout Standard
We define the language 
\begin_inset Formula $\lang X$
\end_inset

 generated by a variable 
\begin_inset Formula $X$
\end_inset

 a bit later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Polynomials"

\end_inset

.
\end_layout

\begin_layout Standard
An important property of a variable is the length of its shortest producible
 word.
\end_layout

\begin_layout Definition
The variable norm is a function 
\begin_inset Formula $\norm{\cdot}:V^{*}\to\left(\mathbb{N}\cup\left\{ \infty\right\} \right)$
\end_inset

.
 Given a variable word 
\begin_inset Formula $\alpha\in V^{*}$
\end_inset

, 
\begin_inset Formula $\norm{\alpha}$
\end_inset

 equals the length of the shortest terminal word 
\begin_inset Formula $w\in T^{*}$
\end_inset

 which can be produced from 
\begin_inset Formula $\alpha$
\end_inset

, i.e.
\begin_inset Formula 
\[
\norm{\alpha}:=\inf_{w\in\lang{\alpha}}\left|w\right|.
\]

\end_inset

In case that 
\begin_inset Formula $\alpha$
\end_inset

 contains a variable which produces no single finite word, 
\begin_inset Formula $\alpha$
\end_inset

 itself will also produce no single finite word, in which case 
\begin_inset Formula $\norm{\alpha}=\infty$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
A grammar is normed iff all its variables produce at least one finite word,
 i.e.
\begin_inset Formula 
\[
\forall X\in V:\,\norm X\neq\infty.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
A grammar 
\begin_inset Formula $G$
\end_inset

 is in 
\emph on
Greibach normal form
\emph default
 (GNF) iff each production rule has the form 
\begin_inset Formula $X\to a\alpha$
\end_inset

, where 
\begin_inset Formula $X\in V$
\end_inset

, 
\begin_inset Formula $a\in T$
\end_inset

 and 
\begin_inset Formula $\alpha\in V^{*}$
\end_inset

.
 If the length of the longest 
\begin_inset Formula $\alpha$
\end_inset

 is 
\begin_inset Formula $k$
\end_inset

, then 
\begin_inset Formula $G$
\end_inset

 is in 
\begin_inset Formula $k$
\end_inset

-GNF.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:Example-grammar"

\end_inset

Consider the following grammar:
\begin_inset Formula 
\begin{align*}
X & \to aX+bZ\\
Y & \to bZZ+aX\\
Z & \to c
\end{align*}

\end_inset

This is a simple deterministic grammar in 2-GNF, as there are maximally
 two variables on the right side of a production rule, namely in 
\begin_inset Formula $Y\to bZZ$
\end_inset

.
 To visualise the grammar, we may construct a production graph as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Production-graph"

\end_inset

:
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->, node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node (X)                 {$X$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Y)  [right of = X] {$Y$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (Z)  [below of = X] {$Z$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (ZZ) [right of = Z] {$ZZ$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (e)  [below of = Z] {$
\backslash
varepsilon$};
\end_layout

\begin_layout Plain Layout

  
\backslash
path (X)  edge[loop above] node {$a$} (X)
\end_layout

\begin_layout Plain Layout

             edge             node {$b$} (Z)
\end_layout

\begin_layout Plain Layout

        (Y)  edge             node {$a$} (X)
\end_layout

\begin_layout Plain Layout

             edge             node {$b$} (ZZ)
\end_layout

\begin_layout Plain Layout

        (Z)  edge             node {$c$} (e)
\end_layout

\begin_layout Plain Layout

        (ZZ) edge             node {$c$} (Z);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Production-graph"

\end_inset

Production graph for example grammar.
\end_layout

\end_inset


\end_layout

\end_inset

 We interpret this graph as follows:
\end_layout

\begin_layout Itemize
Each edge represents a variable word.
\end_layout

\begin_deeper
\begin_layout Itemize
Each vertex with label 
\begin_inset Formula $a\in T$
\end_inset

 from 
\begin_inset Formula $w=X\beta$
\end_inset

 to 
\begin_inset Formula $w'$
\end_inset

 expresses that there exists a production rule 
\begin_inset Formula $\left(X,a\alpha\right)\in P$
\end_inset

 such that 
\begin_inset Formula $w'=\alpha\beta$
\end_inset

.
\end_layout

\begin_layout Itemize
Each path from a variable word 
\begin_inset Formula $w$
\end_inset

 to 
\begin_inset Formula $\varepsilon$
\end_inset

 represents a terminal word produced by 
\begin_inset Formula $w$
\end_inset

.
\end_layout

\begin_layout Itemize
The length of the shortest path from a terminal word 
\begin_inset Formula $w$
\end_inset

 to 
\begin_inset Formula $\varepsilon$
\end_inset

 is equivalent to 
\begin_inset Formula $\norm w$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Example
For example, 
\begin_inset Formula $\norm X=2$
\end_inset

, 
\begin_inset Formula $\norm Y=3$
\end_inset

 and 
\begin_inset Formula $\norm Z=1$
\end_inset

.
 Also, among others, 
\begin_inset Formula $bcc\in\lang Y$
\end_inset

 and 
\begin_inset Formula $aa^{*}bc\subset\lang Y$
\end_inset

 hold.
\end_layout

\begin_layout Subsection
Simple deterministic grammars
\end_layout

\begin_layout Definition
A simple deterministic grammar (or simple context-free grammar), short SDG,
 is a context-free grammar in Greibach normal form, with the condition that
 for each variable 
\begin_inset Formula $X\in V$
\end_inset

 and each 
\begin_inset Formula $a\in T$
\end_inset

, there exists at most one rule 
\begin_inset Formula $X\to a\alpha$
\end_inset

 in 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Simple deterministic grammars are a subclass of context-free grammars; in
 fact, the relation between several language classes is 
\begin_inset Formula 
\[
\lang{\mathrm{SDG}}\subset\lang{\mathrm{DETCF}}\subset\lang{\mathrm{CF}},
\]

\end_inset

where 
\begin_inset Formula $\mathrm{DETCF}$
\end_inset

 denotes deterministic context-free grammars and 
\begin_inset Formula $\mathrm{CF}$
\end_inset

 denotes context-free grammars.
 
\begin_inset CommandInset citation
LatexCommand cite
key "harrison1978"

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:2^n-grammar"

\end_inset

Consider the following grammar:
\begin_inset Formula 
\begin{align*}
F_{0} & \to a\\
F_{n+1} & \to aF_{n}F_{n}
\end{align*}

\end_inset

All variables of this grammar produce exactly one word.
 Furthermore, the greatest norm of all variables is exponential in the number
 of variables.
\end_layout

\begin_layout Lemma
For the grammar from example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:2^n-grammar"

\end_inset

 it holds that 
\begin_inset Formula $\norm{F_{n}}=2^{n+1}-1$
\end_inset

.
\end_layout

\begin_layout Proof
By induction on 
\begin_inset Formula $n$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $n=0$
\end_inset

: 
\begin_inset Formula $\norm{F_{0}}=1=2^{1}-1$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n+1$
\end_inset

: 
\begin_inset Formula $\norm{F_{n+1}}=1+2\cdot\norm{F_{n}}\overset{\text{ind.}}{=}1+2\cdot\left(2^{n+1}-1\right)=1+2^{n+2}-2=2^{n+2}-1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
Polynomials
\begin_inset CommandInset label
LatexCommand label
name "sec:Polynomials"

\end_inset


\end_layout

\begin_layout Standard
We use polynomials to define the language of a simple deterministic grammar.
 Because the term 
\begin_inset Quotes eld
\end_inset

polynomial
\begin_inset Quotes erd
\end_inset

 is polysemous, we need to define our notion of polynomials.
\end_layout

\begin_layout Standard
Let us start by defining some algebraic structures, which serve us later
 in the definitions of polynomials.
 For a more detailed source, see 
\begin_inset CommandInset citation
LatexCommand cite
key "berstel1984"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Monoid
\end_layout

\end_inset

A monoid is a pair 
\begin_inset Formula $\left(A,\cdot\right)$
\end_inset

 such that 
\begin_inset Formula $A$
\end_inset

 is a set and 
\begin_inset Formula $\cdot$
\end_inset

 is an associative operation such that
\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $a,b\in A$
\end_inset

, 
\begin_inset Formula $a\cdot b\in A$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
For all 
\begin_inset Formula $a,b,c\in A$
\end_inset

, 
\begin_inset Formula $a\cdot\left(b\cdot c\right)=\left(a\cdot b\right)\cdot c$
\end_inset

.
\end_layout

\begin_layout Itemize
There exists a neutral element 
\begin_inset Formula $n\in A$
\end_inset

 such that for all 
\begin_inset Formula $a\in A$
\end_inset

, 
\begin_inset Formula $a\cdot n=n\cdot a=a$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Definition
If it holds additionally for all 
\begin_inset Formula $a,b\in A$
\end_inset

 that 
\begin_inset Formula $a\cdot b=b\cdot a$
\end_inset

, then we call the monoid 
\emph on
commutative
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semiring
\end_layout

\end_inset

A semiring is a 3-tuple 
\begin_inset Formula $\left(A,\cdot,+\right)$
\end_inset

 such that
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(A,+\right)$
\end_inset

 is a commutative monoid, whose neutral element is noted 0.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(A,\cdot\right)$
\end_inset

 is a monoid, whose neutral element is noted 1.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\cdot$
\end_inset

 distributes over 
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Itemize
For each 
\begin_inset Formula $a\in A$
\end_inset

 we have 
\begin_inset Formula $a\cdot0=0\cdot a=0$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Definition
If it holds additionally for all 
\begin_inset Formula $a,b\in A$
\end_inset

 that 
\begin_inset Formula $a\cdot b=b\cdot a$
\end_inset

, then we call the semiring commutative.
\end_layout

\begin_layout Standard
In particular, the boolean semiring 
\begin_inset Formula $\mathbb{B}=\left(\left\{ 0,1\right\} ,\cdot,+\right)$
\end_inset

 is defined by 
\begin_inset Formula $1+1=1$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Formal power series
\end_layout

\end_inset

A formal power series 
\begin_inset Formula $S$
\end_inset

 is a total function from 
\begin_inset Formula $X^{*}$
\end_inset

 to 
\begin_inset Formula $K$
\end_inset

.
 The image of a word 
\begin_inset Formula $w\in X^{*}$
\end_inset

 with respect to 
\begin_inset Formula $S$
\end_inset

 is noted as 
\begin_inset Formula $\left(S,w\right)$
\end_inset

 and is called 
\emph on
coefficient
\emph default
 of 
\begin_inset Formula $w$
\end_inset

.
 The 
\emph on
support
\emph default
 of 
\begin_inset Formula $S$
\end_inset

 is defined as
\begin_inset Formula 
\[
\supp\left(S\right):=\left\{ w\in X^{*}\mid\left(S,w\right)\neq0\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semiring of formal power series
\end_layout

\end_inset

The set of formal power series over 
\begin_inset Formula $X$
\end_inset

 with coefficients in 
\begin_inset Formula $K$
\end_inset

 is noted 
\begin_inset Formula $K\left\langle \left\langle X\right\rangle \right\rangle $
\end_inset

.
 We enclose
\begin_inset Note Note
status open

\begin_layout Plain Layout
the right word?
\end_layout

\end_inset

 
\begin_inset Formula $K\left\langle \left\langle X\right\rangle \right\rangle $
\end_inset

 with a semiring structure as follows: If 
\begin_inset Formula $S,T$
\end_inset

 are two series, their sum is defined as
\begin_inset Formula 
\[
\left(S+T,w\right):=\left(S,w\right)+\left(T,w\right),
\]

\end_inset

and their product is defined as
\begin_inset Formula 
\[
\left(ST,w\right):=\sum_{uv=w}\left(S,u\right)\left(T,v\right),
\]

\end_inset

where the sum is finite.
\end_layout

\begin_layout Definition
Based on this, we also define
\begin_inset Formula 
\[
K\left\langle X\right\rangle :=\left\{ S\in K\left\langle \left\langle X\right\rangle \right\rangle \mid\left|\supp\left(S\right)\right|<\infty\right\} 
\]

\end_inset

to be the set of elements in 
\begin_inset Formula $K\left\langle \left\langle X\right\rangle \right\rangle $
\end_inset

 with finite support.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Polynomial
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "def:Polynomial"

\end_inset

Polynomials over 
\begin_inset Formula $\Sigma=V\cup T$
\end_inset

 are the elements of the noncommutative semiring
\begin_inset Formula 
\[
R=\mathbb{B}\left\langle \Sigma\right\rangle .
\]

\end_inset


\end_layout

\begin_layout Standard
For each variable of a grammar, we define its grammar polynomial, which
 is the polynomial representation of all production rules belonging to the
 variable.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Grammar polynomial
\end_layout

\end_inset

For a grammar 
\begin_inset Formula $G=\left(V,T,P\right)$
\end_inset

, the grammar polynomial of a variable 
\begin_inset Formula $X\in V$
\end_inset

 is 
\begin_inset Formula 
\[
\Gr X=\sum_{\left(X,\alpha\right)\in P}\alpha.
\]

\end_inset


\end_layout

\begin_layout Example
Given a variable 
\begin_inset Formula $X$
\end_inset

 defined by its production rules
\begin_inset Formula 
\[
X\to a+B+cDE,
\]

\end_inset

the support of 
\begin_inset Formula $X$
\end_inset

 is 
\begin_inset Formula $\supp\left(X\right)=\left\{ a,B,cDE\right\} $
\end_inset

 and the grammar polynomial of 
\begin_inset Formula $X$
\end_inset

 is 
\begin_inset Formula $\Gr X=a+B+cDE$
\end_inset

.
\end_layout

\begin_layout Standard
We define the language generated by a polynomial.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Polynomial language
\end_layout

\end_inset

The language generated by a polynomial 
\begin_inset Formula $p$
\end_inset

 is defined as 
\begin_inset Formula 
\[
\lang p:=\left\{ w\in T^{*}\mid p\overset{*}{\to}w\right\} ,
\]

\end_inset

where 
\begin_inset Formula $\overset{*}{\to}$
\end_inset

 is the reflexive and transitive closure of the derivation relation, which
 is defined as in 
\begin_inset CommandInset citation
LatexCommand cite
key "carton2008"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is the derivation relation?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "IsaTeX/Norm_defs.tex"

\end_inset


\end_layout

\begin_layout Section
General-purpose parts
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
isamarkupheader}[1]{
\backslash
subsection{#1}}
\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "IsaTeX/AList_ext.tex"

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "IsaTeX/Partition_iterate.tex"

\end_inset


\end_layout

\begin_layout Section
Norm calculation algorithm
\end_layout

\begin_layout Subsection
Idea
\end_layout

\begin_layout Standard
In the original OCaml program to construct equivalence proofs, the user
 had to provide an order 
\begin_inset Formula $\preceq$
\end_inset

 with the grammar, meaning that for all variables 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 of the grammar, if 
\begin_inset Formula $X\preceq Y$
\end_inset

, then 
\begin_inset Formula $\left\Vert X\right\Vert \leq\left\Vert Y\right\Vert $
\end_inset

.
 In the implementation, this was solved by providing the variables in a
 list, and this list had to be sorted by ascending norm.
 That way, we could ignore production rules with variables not having appeared
 before in the list, because their norm would by definition be greater or
 equal to the norm of the current variable and could therefore not induce
 the norm for the current variable.
 In case that the norm of a variable was calculated to be smaller than the
 norm of a variable at an earlier position in the list, the norm calculation
 quit with an error.
\end_layout

\begin_layout Standard
While this was a reliable and fast method to calculate norms, this method
 had the disadvantage that the user had to construct a variable order 
\begin_inset Formula $\preceq$
\end_inset

 when formulating the grammar, and formalising variable orders would have
 imposed an unnatural and in principle unnecessary restriction on grammars.
 For this reason, we looked into different approaches to generate the norm:
 One was to identify variables 
\begin_inset Formula $V_{\infty}$
\end_inset

 with an infinite norm, remove them from the grammar, then also remove all
 production rules containing elements of 
\begin_inset Formula $V_{\infty}$
\end_inset

 from the grammar.
 But how to find all variables with infinite norm? Consider the following
 example:
\begin_inset Formula 
\begin{align*}
X & \to aY\\
Y & \to aZ\\
Z & \to aX
\end{align*}

\end_inset

As we can see, none of these variables has a finite norm, but to find that
 out, we have to look at each of these variables.
 An easier problem is to find the set 
\begin_inset Formula $V_{n}$
\end_inset

 of all variables which have a finite norm --- having this set and knowing
 that 
\begin_inset Formula $V=V_{\infty}\cup V_{n}$
\end_inset

 with 
\begin_inset Formula $V_{\infty}\cap V_{n}=\emptyset$
\end_inset

, we can obtain 
\begin_inset Formula $V_{\infty}$
\end_inset

 from 
\begin_inset Formula $V$
\end_inset

 and 
\begin_inset Formula $V_{n}$
\end_inset

.
 So how to calculate 
\begin_inset Formula $V_{n}$
\end_inset

? We can use the following algorithm to do that, initialising 
\begin_inset Formula $V_{n}$
\end_inset

 with 
\begin_inset Formula $\emptyset$
\end_inset

:
\end_layout

\begin_layout Enumerate
Obtain all variables from grammar which have a production rule containing
 only variables in 
\begin_inset Formula $V_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
If such variables exist, remove those variables from grammar and add them
 to 
\begin_inset Formula $V_{n}$
\end_inset

, otherwise the algorithm terminates and returns 
\begin_inset Formula $V_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Go to 1.
\end_layout

\begin_layout Standard
As we can see, the amount of variables in the grammar constantly decreases,
 therefore the algorithm terminates, because we consider only grammars with
 a finite set of variables.
\end_layout

\begin_layout Standard
This algorithm therefore gives as the means to calculate 
\begin_inset Formula $V_{n}$
\end_inset

, and thus also 
\begin_inset Formula $V_{\infty}$
\end_inset

.
 Knowing this information, does it help us to calculate the norms? One thing
 that we can do now is to remove all production rules from the grammar which
 contain variables in 
\begin_inset Formula $V_{\infty}$
\end_inset

, for they will not induce any finite norm and are therefore irrelevant
 for norm calculation.
 Now the first idea might be to calculate the norm of a variable 
\begin_inset Formula $X$
\end_inset

 as soon as norms for all variables of the production rules of 
\begin_inset Formula $X$
\end_inset

 have been calculated.
 We can, however, easily find a counterexample for this approach:
\begin_inset Formula 
\begin{align*}
A & \to a\\
B & \to bAA+cC\\
C & \to cAA+bB
\end{align*}

\end_inset

Here, using the approach above, we will wait for 
\begin_inset Formula $B$
\end_inset

 to be normed because 
\begin_inset Formula $C$
\end_inset

 was not normed yet, but also 
\begin_inset Formula $C$
\end_inset

 will wait for 
\begin_inset Formula $B$
\end_inset

, so we are in a deadlock.
 Therefore, we decided to calculate a norm for a variable as soon as all
 variables of 
\emph on
any
\emph default
 of the variable's production rules have a known norm.
 This, however, will not always yield the correct norm, but merely an overestima
tion of the norms --- observe:
\begin_inset Formula 
\begin{align*}
A_{1} & \to a & \rightsquigarrow\left(A_{1},1,a,\left[\right]\right)\\
A_{2} & \to aA_{1} & \rightsquigarrow\left(A_{2},2,a,\left[A_{1}\right]\right)\\
B & \to bA_{1}A_{1}A_{1}+cA_{2} & {\color{red}\rightsquigarrow\left(B,4,b,\left[A_{1},A_{1},A_{1}\right]\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In this example, we have to choose of which variable we should calculate
 the norm first, and if we choose 
\begin_inset Formula $B$
\end_inset

 instead of 
\begin_inset Formula $A_{2}$
\end_inset

, then the norm of 
\begin_inset Formula $B$
\end_inset

 will be too big, therefore wrong.
 However, because we overestimate norms, we can try to make the norms smaller
 after the calculation of the initial norms, thus finding a fixpoint where
 the norms to not change anymore, at which point the norms will be minimal
 and therefore valid.
 For the example above, we only need a single refinement step to reach the
 fixpoint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
A_{1} & \to a & \rightsquigarrow\left(A_{1},1,a,\left[\right]\right)\\
A_{2} & \to aA_{1} & \rightsquigarrow\left(A_{2},2,a,\left[A_{1}\right]\right)\\
B & \to bA_{1}A_{1}A_{1}+cA_{2} & {\color{red}\rightsquigarrow\left(B,4,b,\left[A_{1},A_{1},A_{1}\right]\right)}{\color{green}\rightsquigarrow\left(B,3,c,\left[A_{2}\right]\right)}
\end{align*}

\end_inset

We can reach such a fixpoint after 
\begin_inset Formula $\mathcal{O}(n)$
\end_inset

 iterations, where 
\begin_inset Formula $n$
\end_inset

 is the number of variables.
 Consider the following example, illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Norm-example-illustration"

\end_inset

:
\begin_inset Formula 
\begin{align*}
L_{1} & \to l & E_{1} & \to e & X_{1} & \to lL_{4}+eE_{3}\\
L_{n+1} & \to lL_{n} & E_{n+1} & \to eE_{n}E_{n} & X_{n+1} & \to xX_{n}
\end{align*}

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includesvg[width=0.4
\backslash
columnwidth]{Norm_Dilemma}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Norm example illustration.
\begin_inset CommandInset label
LatexCommand label
name "fig:Norm-example-illustration"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The construction has been chosen in such a way that 
\begin_inset Formula $L_{i}$
\end_inset

 grows linearly, while 
\begin_inset Formula $E_{i}$
\end_inset

 grows exponentially.
 If we then iteratively calculate the norms, we can calculate the norms
 of 
\begin_inset Formula $E_{3}$
\end_inset

 and 
\begin_inset Formula $L_{3}$
\end_inset

 in the same iteration.
 At that point, let us assume we calculate 
\begin_inset Formula $\left\Vert X_{1}\right\Vert $
\end_inset

 to be 
\begin_inset Formula $1+\left\Vert E_{3}\right\Vert $
\end_inset

 instead of 
\begin_inset Formula $1+\left\Vert L_{4}\right\Vert $
\end_inset

, because we have previously already calculated the norm of 
\begin_inset Formula $E_{3}$
\end_inset

, but the norm of 
\begin_inset Formula $L_{4}$
\end_inset

 is unknown yet.
 However, 
\begin_inset Formula $E_{3}$
\end_inset

 was a wrong choice, because the norm of 
\begin_inset Formula $L_{4}$
\end_inset

 will be calculated one step later to be smaller than the norm of 
\begin_inset Formula $E_{3}$
\end_inset

, but having already calculated 
\begin_inset Formula $\left\Vert X_{1}\right\Vert $
\end_inset

, this error will propagate until 
\begin_inset Formula $X_{n}$
\end_inset

.
 In every iteration of the following fixpoint calculation, however, only
 one 
\begin_inset Formula $X_{i}$
\end_inset

 will decrease, thus amounting to a total of about 
\begin_inset Formula $n$
\end_inset

 iterations.
 Because in every iteration, we look through all norms if they are correct,
 our fixpoint calculation has complexity 
\begin_inset Formula $\mathcal{O}(n^{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
isamarkupheader}[1]{}
\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "IsaTeX/Norm_funs.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
isamarkupheader}[1]{
\backslash
section{#1}}
\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "IsaTeX/Norm_proofs.tex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Statistics
\end_layout

\begin_layout Section
Integration with existing code
\end_layout

\begin_layout Standard
The export of the Isabelle code to OCaml turned out to be relatively simple.
 However, by default, natural numbers are encoded as inductive datatype
 of the form 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type nat = Zero | Succ of nat
\end_layout

\end_inset

As this representation is very inconvenient to use in OCaml, we imported
 the theory Code_Target_Nat to make Isabelle export the code using the OCaml
 datatype big_int.
 Following that, we only had to convert the OCaml code from int to big_int,
 which turned out to be relatively simple and did not have a noticable impact
 on the performance of the program.
\end_layout

\begin_layout Standard
Furthermore, to use the exported functions in OCaml, we needed to supply
 orderings for the used datatypes.
 As we compare only tuples, lists, characters and integers, which are all
 supported by the OCaml polymorphic comparison operator 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

, we constructed the required orderings in OCaml using 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

<=
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Literature"
options "bibtotoc,abbrv"

\end_inset


\end_layout

\end_body
\end_document
